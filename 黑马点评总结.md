

## 黑马点评总结

[TOC]

![image-20230311143030799](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/image-20230311143030799.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/4c3da21ba08d4d708aacdd7366d7c099.png#pic_center)

#### 项目架构

![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/abf1246ffdca4c90a1b00f36905892bf.png)

- 短信登录

这一块我们会使用redis共享session来实现

- 商户查询缓存

通过本章节，我们会理解缓存击穿，缓存穿透，缓存雪崩等问题，让小伙伴的对于这些概念的理解不仅仅是停留在概念上，更是能在代码中看到对应的内容

- 优惠卷秒杀

通过本章节，我们可以学会Redis的计数器功能， 结合Lua完成高性能的redis操作，同时学会Redis分布式锁的原理，包括Redis的三种消息队列

- 附近的商户

我们利用Redis的GEOHash来完成对于地理坐标的操作

- UV统计

主要是使用Redis来完成统计功能

- 用户签到

使用Redis的BitMap数据统计功能

- 好友关注

基于Set集合的关注、取消关注，共同关注等等功能，这一块知识咱们之前就讲过，这次我们在项目中来使用一下

- 打人探店

基于List来完成点赞列表的操作，同时基于SortedSet来完成点赞的排行榜功能

##### 有关当前模型

手机或者app端发起请求，请求我们的nginx服务器，nginx基于七层模型走的事HTTP协议，可以实现基于Lua直接绕开tomcat访问redis，也可以作为静态资源服务器，轻松扛下上万并发， 负载均衡到下游tomcat服务器，打散流量，我们都知道一台4核8G的tomcat，在优化和处理简单业务的加持下，大不了就处理1000左右的并发， 经过nginx的负载均衡分流后，利用集群支撑起整个项目，同时nginx在部署了前端项目后，更是可以做到动静分离，进一步降低tomcat服务的压力，这些功能都得靠nginx起作用，所以nginx是整个项目中重要的一环。

#### 短信登录

![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/942d4aee3ce54c8994ffe3a13add8d58.png)

![image-20230311143932501](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/image-20230311143932501.png)

1. **发送短信验证码**![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/7285e2937f614f8b9616a2b002303bd5.png)

2.**短信验证码登录和注册功能**![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/cdf9c925ab0d4777a2371615b01da019.png)

3.**登录验证功能**![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/bd2421c0b49746e598d88b819e2b7afc.png)

![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/95c7a49dc3df4b54a1f8279149022c9b.png)

Controller

```java
@Slf4j
@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    //可以消除需要注入哪个 bean 的问题
    @Qualifier("userService")
    private IUserService userService;

    @Autowired
    private IUserInfoService userInfoService;

    /**
     * 发送手机验证码
     */
    @PostMapping("code")
    public Result sendCode(@RequestParam("phone") String phone, HttpSession session) {
        // 发送短信验证码并保存验证码
        return userService.sendCode(phone,session);
    }

    /**
     * 登录功能
     * @param loginForm 登录参数，包含手机号、验证码；或者手机号、密码
     */
    @PostMapping("/login")
    public Result login(@RequestBody LoginFormDTO loginForm, HttpSession session){
        // 实现登录功能
        return userService.login(loginForm,session);
    }

    /**
     * 登出功能
     */
    @PostMapping("/logout")
    public Result logout(){
        // TODO 实现登出功能
        return userService.logout();
    }

    /**
     * 校验登陆状态
     * @return
     */
    @GetMapping("/me")
    public Result me(){
        // 获取当前登录的用户并返回
        UserDTO user = UserHolder.getUser();
        return Result.ok(user);
    }

    @GetMapping("/info/{id}")
    public Result info(@PathVariable("id") Long userId){
        // 查询详情
        UserInfo info = userInfoService.getById(userId);
        if (info == null) {
            // 没有详情，应该是第一次查看详情
            return Result.ok();
        }
        info.setCreateTime(null);
        info.setUpdateTime(null);
        // 返回
        return Result.ok(info);
    }
    
}
```

##### 实现登录拦截功能

当用户发起请求时，会访问我们像tomcat注册的端口，任何程序想要运行，都需要有一个线程对当前端口号进行监听，tomcat也不例外，当监听线程知道用户想要和tomcat连接连接时，那会由监听线程创建socket连接，socket都是成对出现的，用户通过socket像互相传递数据，当tomcat端的socket接受到数据后，此时监听线程会从tomcat的线程池中取出一个线程执行用户请求，在我们的服务部署到tomcat后，线程会找到用户想要访问的工程，然后用这个线程转发到工程中的controller，service，dao中，并且访问对应的DB，在用户执行完请求后，再统一返回，再找到tomcat端的socket，再将数据写回到用户端的socket，完成请求和响应

通过以上讲解，我们可以得知 每个用户其实对应都是去找tomcat线程池中的一个线程来完成工作的， 使用完成后再进行回收，既然每个请求都是独立的，所以在每个用户去访问我们的工程时，我们可以使用threadlocal来做到线程隔离，每个线程操作自己的一份数据

![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/bdeb7e56070d475a908b0aeb88789027.png)

**温馨小贴士：关于threadlocal**

如果小伙伴们看过threadLocal的源码，你会发现在threadLocal中，无论是他的put方法和他的get方法， 都是先从获得当前用户的线程，然后从线程中取出线程的成员变量map，只要线程不一样，map就不一样，所以可以通过这种方式来做到线程隔离

```java
@Slf4j
public class LoginInterception implements HandlerInterceptor {

    @Override
    /*
    这个是请求预处理的方法，只有当这个方法返回值为 true 的时候，后面的方法才会执行
    SpringMVC 中的拦截器，相当于 Jsp/Servlet 中的过滤器，只不过拦截器的功能更为强大。
    */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1. 判断是否需要拦截：ThreadLocal中是否有用户
        if (UserHolder.getUser() == null){
            response.setStatus(401);
            return false;  //拦截
        }
        //有用户，则放行
        return true;
    }

}
```

让拦截器生效

```java
@Configuration
public class MvcConfig implements WebMvcConfigurer {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;
    /*
    这个类有@Configuration注解，是由Spring帮我们生成的，所以可以在这里注入生成template，再放到拦截器里
     */

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //刷新拦截器
        registry.addInterceptor(new RefreshTokenInterception(stringRedisTemplate));
        //登录拦截器
        registry.addInterceptor(new LoginInterception())
                .excludePathPatterns(   //这些功能是不拦截的
                        "/user/code",
                        "/user/login",
                        "/blog/hot",
                        "/shop/**",
                        "/shop-type/**",
                        "/voucher/**"
                );
    }
}
```

![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/d342787693314d5582c278d9016ad0b3.png)

![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/b22df48db9804e1d9a9596c05e0c9a91.png)

##### 隐藏用户敏感信息

我们通过浏览器观察到此时用户的全部信息都在，这样极为不靠谱，所以我们应当在返回用户信息之前，将用户的敏感信息进行隐藏，采用的核心思路就是书写一个UserDto对象，这个UserDto对象就没有敏感信息了，我们在返回前，将有用户敏感信息的User对象转化成没有敏感信息的UserDto对象，那么就能够避免这个尴尬的问题了

**在登录方法处修改**

```java
//7.保存用户信息到session中
session.setAttribute("user", BeanUtils.copyProperties(user,UserDTO.class));
```

**在拦截器处：**

```java
//5.存在，保存用户信息到Threadlocal
UserHolder.saveUser((UserDTO) user);
```

**在UserHolder处：将user对象换成UserDTO**

```java
public class UserHolder {
    private static final ThreadLocal<UserDTO> tl = new ThreadLocal<>();

    public static void saveUser(UserDTO user){
        tl.set(user);
    }

    public static UserDTO getUser(){
        return tl.get();
    }

    public static void removeUser(){
        tl.remove();
    }
}
```

#### session共享问题

**核心思路分析：**

每个tomcat中都有一份属于自己的session,假设用户第一次访问第一台tomcat，并且把自己的信息存放到第一台服务器的session中，但是第二次这个用户访问到了第二台tomcat，那么在第二台服务器上，肯定没有第一台服务器存放的session，所以此时 整个登录拦截功能就会出现问题，我们能如何解决这个问题呢？早期的方案是session拷贝，就是说虽然每个tomcat上都有不同的session，但是每当任意一台服务器的session修改时，都会同步给其他的Tomcat服务器的session，这样的话，就可以实现session的共享了

但是这种方案具有两个大问题

1、每台服务器中都有完整的一份session数据，服务器压力过大。

2、session拷贝数据时，可能会出现延迟

所以咱们后来采用的方案都是基于redis来完成，我们把session换成redis，redis数据本身就是共享的，就可以避免session共享的问题了

#### Redis代替session的业务流程

#### 设计key的结构

首先我们要思考一下利用redis来存储数据，那么到底使用哪种结构呢？由于存入的数据比较简单，我们可以考虑使用String，或者是使用哈希，如下图，如果使用String，同学们注意他的value，用多占用一点空间，如果使用哈希，则他的value中只会存储他数据本身，如果不是特别在意内存，其实使用String就可以啦。

##### 设计key的具体细节

所以我们可以使用String结构，就是一个简单的key，value键值对的方式，但是关于key的处理，session他是每个用户都有自己的session，但是redis的key是共享的，咱们就不能使用code了

在设计这个key的时候，我们之前讲过需要满足两点

1、key要具有唯一性

2、key要方便携带

如果我们采用phone：手机号这个的数据来存储当然是可以的，但是如果把这样的敏感数据存储到redis中并且从页面中带过来毕竟不太合适，所以我们在后台生成一个随机串token，然后让前端带来这个token就能完成我们的整体逻辑了

##### 整体访问流程

当注册完成后，用户去登录会去校验用户提交的手机号和验证码，是否一致，如果一致，则根据手机号查询用户信息，不存在则新建，最后将用户数据保存到redis，并且生成token作为redis的key，当我们校验用户是否登录时，会去携带着token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到threadLocal中，并且放行。

####  解决状态登录刷新问题

![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/9f06eba6bdab4c8eb132dc680fc9263a.png)

我们可以在原有的拦截器上新增一个拦截器，拦截一切路径。

![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/5d6320f988a94c9f9dff10756dc83bdc.png)

**RefreshTokenInterceptor**

```java
public class RefreshTokenInterception implements HandlerInterceptor {

    private StringRedisTemplate stringRedisTemplate;

    public RefreshTokenInterception(StringRedisTemplate stringRedisTemplate){
        this.stringRedisTemplate = stringRedisTemplate;
    }

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1. 获取请求头中的token
        String token = request.getHeader("authorization");

        if(StrUtil.isBlank(token)){
            return true;
        }
        // 2. 基于token获取redis中的用户
        Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token);
        // 3. 判断用户是否存在
        if(userMap.isEmpty()) {
            // 4. 不存在
            return true;
        }
        // 5. 将查询到的Hash数据转为UserDto对象
        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);
        // 6. 存在，用户信息保存到ThreadLocal
        UserHolder.saveUser(userDTO);
        // 7. 刷新token有效期
        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY+token,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);
        return true;
    }

    @Override
    /**
     * 调用前提：preHandle返回true
     * DispatcherServlet进行视图的渲染之后
     * 多用于清理资源
     */
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        //移除用户
        UserHolder.removeUser();
    }
}
```

**LoginInterceptor**

```java
@Slf4j
public class LoginInterception implements HandlerInterceptor {

    @Override
    /*
    这个是请求预处理的方法，只有当这个方法返回值为 true 的时候，后面的方法才会执行
    SpringMVC 中的拦截器，相当于 Jsp/Servlet 中的过滤器，只不过拦截器的功能更为强大。
    */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1. 判断是否需要拦截：ThreadLocal中是否有用户
        if (UserHolder.getUser() == null){
            response.setStatus(401);
            return false;  //拦截
        }
        //有用户，则放行
        return true;
    }

}
```



#### 完整业务流程代码实现

接口

```java
public interface IUserService extends IService<User> {

    Result sendCode(String phone, HttpSession session);


    Result login(LoginFormDTO loginForm, HttpSession session);

    Result sign();

    Result logout();
}
```

业务类

```java
@Slf4j
@Service("userService")
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements IUserService {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Override
    public Result sendCode(String phone, HttpSession session) {
        //1. 校验手机号
        if(RegexUtils.isPhoneInvalid(phone)){
            //2. 不符合，返回错误信息
            return Result.fail("手机号码格式错误！");
        }
        //3. 符合，生成验证码
        String code = RandomUtil.randomNumbers(6);

        String key = RedisConstants.LOGIN_CODE_KEY;
        //4. 保存验证码到redis
        stringRedisTemplate.opsForValue().set( key + phone,code, RedisConstants.LOGIN_CODE_TTL, TimeUnit.SECONDS);

        //5. 发送验证码 实际项目借助第三方平台API
        log.debug("发送短信验证码成功,接收手机号：{} => 验证码：{}",phone,code);

        //返回ok
        return Result.ok();
    }

    @Override
    public Result login(LoginFormDTO loginForm, HttpSession session) {

        String phone = loginForm.getPhone();

        //1. 校验手机号和验证码
        if(RegexUtils.isPhoneInvalid(phone))  return Result.fail("手机号码格式错误！");

        String cacheCode = stringRedisTemplate.opsForValue().get(RedisConstants.LOGIN_CODE_KEY + phone);
        String code = loginForm.getCode();

        if(cacheCode == null || !cacheCode.equals(code)){
            return Result.fail("验证码错误！");
        }

        //2. 一致 根据手机号查用户
        User user = query().eq("phone", phone).one();

        //3. 判断用户是否存在
        if(user == null){
            //不存在，创建新的用户
            user = createUserWithPhone(phone);
        }

        //4. 保存用户到redis
        //4.1 随机生成token, 作为登陆令牌
        String token = UUID.randomUUID().toString(true);  //简单的uuid（不带_）
        //4.2 将User对象转为HashMap存储
        UserDTO userDTO = BeanUtil.copyProperties(user, UserDTO.class);
        Map<String, String> userMap = ObjectToMap.UserDto2Map(userDTO);
        //4.3 存储
        stringRedisTemplate.opsForHash().putAll(RedisConstants.LOGIN_USER_KEY+token, userMap);
        //4.4 设置token有效时间
        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY+token,RedisConstants.LOGIN_USER_TTL,TimeUnit.MINUTES);

        //4.3 将token返回给客户端
        return Result.ok(token);
    }

    private User createUserWithPhone(String phone) {
        // 1. 创建用户
        User user = new User();
        user.setPhone(phone);
        user.setNickName(SystemConstants.USER_NICK_NAME_PREFIX + RandomUtil.randomString(10));
        // 2. 保存用户
        save(user);
        return user;
    }

    @Override
    public Result sign() {
        Long userId = UserHolder.getUser().getId();
        // 获取日期
        LocalDateTime now = LocalDateTime.now();
        String format = now.format(DateTimeFormatter.ofPattern(":yyyyMM"));
        // BitMap底层是基于String数据结构，因此其操作也都封装在字符串相关操作中
        String key = RedisConstants.USER_SIGN_KEY + userId +format;
        int dayOfMonth = now.getDayOfMonth()-1;
        stringRedisTemplate.opsForValue().setBit(key,dayOfMonth,true);
        return Result.ok();
    }

    @Override
    public Result logout() {
        UserHolder.removeUser();
        return Result.ok();
    }
}
```



#### 商户查询缓存![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/549dbc1d6b1d430194af59928a65392f.png)

**缓存(\**Cache),就是数据交换的\**缓冲区**,俗称的缓存就是**缓冲区内的数据**,一般从数据库中获取,存储于本地代码(例如:

```java
例1:Static final ConcurrentHashMap<K,V> map = new ConcurrentHashMap<>(); 本地用于高并发

例2:static final Cache<K,V> USER_CACHE = CacheBuilder.newBuilder().build(); 用于redis等缓存

例3:Static final Map<K,V> map =  new HashMap(); 本地缓存
```

由于其被**Static**修饰,所以随着类的加载而被加载到**内存之中**,作为本地缓存,由于其又被**final**修饰,所以其引用(例3:map)和对象(例3:new HashMap())之间的关系是固定的,不能改变,因此不用担心赋值(=)导致缓存失效;

##### 为什么要使用缓存

一句话:因为**速度快,好用**

缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大降低**用户访问并发量带来的**服务器读写压力

实际开发过程中,企业的数据量,少则几十万,多则几千万,这么大数据量,如果没有缓存来作为"避震器",系统是几乎撑不住的,所以企业会大量运用到缓存技术;

但是缓存也会增加代码复杂度和运营的成本:

#### 如何使用缓存

实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用

**浏览器缓存**：主要是存在于浏览器端的缓存

**应用层缓存：**可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存

**数据库缓存：**在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中

**CPU缓存：**当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存

#### 添加商户缓存![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/26f83cadced24841a7660107d190fbd3.png)

```java
@GetMapping("/{id}")
public Result queryShopById(@PathVariable("id") Long id) {
    //这里是直接查询数据库
    return shopService.queryById(id);
}
```

#### 缓存模型和思路

标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。

#### 数据库缓存不一致解决方案：

由于我们的**缓存的数据源来自于数据库**,而数据库的**数据是会发生变化的**,因此,如果当数据库中**数据发生变化,而缓存却没有同步**,此时就会有**一致性问题存在**,其后果是:用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务,产品口碑等;怎么解决呢？有如下几种方案:

用户使用缓存中的过时数据,就会产生类似多线程数据安全问题,从而影响业务

Cache Aside Pattern 人工编码方式：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案

Read/Write Through Pattern : 由系统本身完成，数据库与缓存的问题交由系统本身去处理

Write Behind Caching Pattern ：调用者只操作缓存，其他线程去异步处理数据库，实现最终一致

#### 数据库和缓存不一致采用什么方案

综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题

操作缓存和数据库时有三个问题需要考虑：

如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来

- 删除缓存还是更新缓存？
  - 更新缓存：每次更新数据库都更新缓存，无效写操作较多
  - 删除缓存：更新数据库时让缓存失效，查询时再更新缓存
- 如何保证缓存与数据库的操作的同时成功或失败？
  - 单体系统，将缓存与数据库操作放在一个事务
  - 分布式系统，利用TCC等分布式事务方案

#### 数据库和缓存不一致采用什么方案

综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题

操作缓存和数据库时有三个问题需要考虑：

如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来

- 删除缓存还是更新缓存？

  - 更新缓存：每次更新数据库都更新缓存，无效写操作较多
  - 删除缓存：更新数据库时让缓存失效，查询时再更新缓存

- 如何保证缓存与数据库的操作的同时成功或失败？

  - 单体系统，将缓存与数据库操作放在一个事务

  - 分布式系统，利用TCC等分布式事务方案

    ​																																																														数据库和缓存不一致采用什么方案

    综合考虑使用方案一，但是方案一调用者如何处理呢？这里有几个问题

    操作缓存和数据库时有三个问题需要考虑：

    如果采用第一个方案，那么假设我们每次操作数据库后，都操作缓存，但是中间如果没有人查询，那么这个更新动作实际上只有最后一次生效，中间的更新动作意义并不大，我们可以把缓存删除，等待再次查询时，将缓存中的数据加载出来

    - 删除缓存还是更新缓存？
      - 更新缓存：每次更新数据库都更新缓存，无效写操作较多
      - 删除缓存：更新数据库时让缓存失效，查询时再更新缓存
    - 如何保证缓存与数据库的操作的同时成功或失败？
      - 单体系统，将缓存与数据库操作放在一个事务
      - 分布式系统，利用TCC等分布式事务方案

#### 缓存穿透问题的解决思路![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/a1e2b57e375c411b937d2d61404d2835.png)

缓存穿透 ：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。

常见的解决方案有两种：

- 缓存空对象![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/92fe854b2a1e4e58ad6f89e456d996cf.png)
  - 优点：实现简单，维护方便
  - 缺点：
    - 额外的内存消耗
    - 可能造成短期的不一致
- 布隆过滤
  - 优点：内存占用较少，没有多余key
  - 缺点：
    - 实现复杂
    - 存在误判可能

缓存空对象思路分析：**当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了

**布隆过滤：**布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，

假设布隆过滤器判断这个数据不存在，则直接返回

这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突

#### 编码解决商品查询的缓存穿透问题

在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的

现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。

在原来的逻辑中，我们如果发现这个数据在mysql中不存在，直接就返回404了，这样是会存在缓存穿透问题的

现在的逻辑中：如果这个数据不存在，我们不会返回404 ，还是会把这个数据写入到Redis中，并且将value设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个value是否是null，如果是null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。

#### 缓存雪崩问题及解决思路

缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。

解决方案：

- 给不同的Key的TTL添加随机值
- 利用Redis集群提高服务的可用性
- 给缓存业务添加降级限流策略
- 给业务添加多级缓存

#### 缓存击穿问题及解决思路![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/dfc17ee72c70450e9b560d8bfac05e74.png)

缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。

常见的解决方案有两种：

- 互斥锁
- 逻辑过期

逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大

解决方案一、使用锁来解决：

因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。

假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。

解决方案二、逻辑过期方案

方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对key设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。

我们把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。

这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。

进行对比

**互斥锁方案：**由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题的发生，且只能串行执行性能肯定受到影响

**逻辑过期方案：** 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦

![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/3fb3a2949fdb4467aace114fa59e01bc.png)

#### 完整业务流程代码实现

Controller

```java
@RestController
@RequestMapping("/shop")
public class ShopController {

    @Resource
    public IShopService shopService;

    /**
     * 根据id查询商铺信息
     * @param id 商铺id
     * @return 商铺详情数据
     */
    @GetMapping("/{id}")
    public Result queryShopById(@PathVariable("id") Long id) {
        //增加缓存功能
        return shopService.queryById(id);
    }

    /**
     * 新增商铺信息
     * @param shop 商铺数据
     * @return 商铺id
     */
    @PostMapping
    public Result saveShop(@RequestBody Shop shop) {
        // 写入数据库
        shopService.save(shop);
        // 返回店铺id
        return Result.ok(shop.getId());
    }

    /**
     * 更新商铺信息
     * @param shop 商铺数据
     * @return 无
     */
    @PutMapping
    public Result updateShop(@RequestBody Shop shop) {
        // 写入数据库
        return shopService.updateShop(shop);
    }

    /**
     * 根据商铺类型分页查询商铺信息
     * @param typeId 商铺类型
     * @param current 页码
     * @return 商铺列表
     */
    @GetMapping("/of/type")
    public Result queryShopByType(
            @RequestParam("typeId") Integer typeId,
            @RequestParam(value = "current", defaultValue = "1") Integer current
    ) {
        // 根据类型分页查询
        Page<Shop> page = shopService.query()
                .eq("type_id", typeId)
                .page(new Page<>(current, SystemConstants.DEFAULT_PAGE_SIZE));
        // 返回数据
        return Result.ok(page.getRecords());
    }

    /**
     * 根据商铺名称关键字分页查询商铺信息
     * @param name 商铺名称关键字
     * @param current 页码
     * @return 商铺列表
     */
    @GetMapping("/of/name")
    public Result queryShopByName(
            @RequestParam(value = "name", required = false) String name,
            @RequestParam(value = "current", defaultValue = "1") Integer current
    ) {
        // 根据类型分页查询
        Page<Shop> page = shopService.query()
                .like(StrUtil.isNotBlank(name), "name", name)
                .page(new Page<>(current, SystemConstants.MAX_PAGE_SIZE));
        // 返回数据
        return Result.ok(page.getRecords());
    }
}
```

接口

```java
public interface IShopService extends IService<Shop> {

    /**
    *@Description: 查询商铺信息（支持缓存）
    *@Param: [id]
    *@return: com.hmdp.dto.Result
    */
    Result queryById(Long id);

    /**
    *@Description: 更新商铺信息（1.更新数据库 2.删缓存）
    *@Param: [shop]
    *@return: com.hmdp.dto.Result
    */
    Result updateShop(Shop shop);
}
```

业务类

```java
@Service
public class ShopServiceImpl extends ServiceImpl<ShopMapper, Shop> implements IShopService {

    @Resource
    private StringRedisTemplate stringRedisTemplate;


    @Autowired
    private CacheClient cacheClient;

    @Override
    public Result queryById(Long id) {
        //缓存穿透
        Shop shop = cacheClient.queryWithPassThrough(RedisConstants.CACHE_SHOP_KEY, id, Shop.class, RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES, (id2) -> getById(id2));

        //互斥锁解决缓存击穿
        if (shop == null) {
            return Result.fail("店铺不存在!");
        }

        return Result.ok(shop);
    }


    //互斥锁解决缓存击穿
    public Shop queryWithMutex(Long id){
        String key = RedisConstants.CACHE_SHOP_KEY + id;
        boolean isWait = true;
        String lockKey = RedisConstants.LOCK_SHOP_KEY+id;
        Shop shop = null;
        //1,从redis查询商铺缓存
        try {
            while (isWait){
                // 1. 从redis中查询商铺缓存(命中)
                String cacheShopJson = stringRedisTemplate.opsForValue().get(key);
                if (StrUtil.isNotBlank(cacheShopJson)){
                    shop = JSONUtil.toBean(cacheShopJson, Shop.class);
                    return shop;
                }

                //实现缓存重建
                //1. 获取互斥锁
                boolean isLock = tryLock(lockKey);
                //2.判断是否获取成功
                if(!isLock){
                    //2.1 失败，则休眠并重试
                    Thread.sleep(50);
                }else {
                    isWait = false;
                }
            }
            //2.2 成功
            //2.2.1 再次检查缓存，做doublecheck，防止是刚好前一个更新完缓存后放了锁，然后被你拿到了
            String cacheShopJson = stringRedisTemplate.opsForValue().get(key);
            if (StrUtil.isNotBlank(cacheShopJson)){
                shop = JSONUtil.toBean(cacheShopJson, Shop.class);
                unlock(lockKey);  //放锁
                return shop;
            }
            //2.2.2 根据id查询数据库
            shop = getById(id);
            stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop), RedisConstants.CACHE_SHOP_TTL, TimeUnit.MINUTES);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            //释放互斥锁
            unlock(lockKey);
        }

        //返回
        return shop;

    }

    private boolean tryLock(String key){
        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS);
        return BooleanUtil.isTrue(flag);
    }

    private void unlock(String key){
        stringRedisTemplate.delete(key);
    }
    @Override
    @Transactional
    public Result updateShop(Shop shop) {
        Long id = shop.getId();
        if (id == null){
            return Result.fail("Shop id is not null");
        }
        //1,更新数据库
        updateById(shop);
        //2.删除缓存
        stringRedisTemplate.delete(RedisConstants.CACHE_SHOP_KEY + id);

        return Result.ok();
    }
}
```

基于StringRedisTemplate封装一个缓存工具类，满足下列需求：

- 方法1：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置TTL过期时间
- 方法2：将任意Java对象序列化为json并存储在string类型的key中，并且可以设置逻辑过期时间，用于处理缓

存击穿问题

- 方法3：根据指定的key查询缓存，并反序列化为指定类型，利用缓存空值的方式解决缓存穿透问题
- 方法4：根据指定的key查询缓存，并反序列化为指定类型，需要利用逻辑过期解决缓存击穿问题

将逻辑进行封装

```java
/**
 * @ClassName: CacheClient
 * @Description: 封装的缓存工具类
 * @Version: 1.0
 */

@Slf4j
@Component
public class CacheClient {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    //线程池
    private static final ExecutorService CACHE_REBUILD_EXXECUTOR = Executors.newFixedThreadPool(10);

    public void set(String key, Object value, Long time, TimeUnit unit){
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value),time,unit);
    }

    public void setWithLogicExpire(String key, Object value, Long time, TimeUnit unit){
        RedisData redisData = new RedisData(LocalDateTime.now().plusSeconds(unit.toSeconds(time)),value);
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));
    }

    /**
    *@Description: 查询+解决缓存穿透 =》 泛型+函数式编程
    *@Param: [keyPrefix 前缀, id, type 泛型的类型, time 有效期, unit, dbFallback 函数式编程，根据id查询数据库的方法]
    *@return: R
    */
    public <R,ID> R queryWithPassThrough(String keyPrefix, ID id, Class<R> type, Long time, TimeUnit unit, Function<ID,R> dbFallback){
        String key = keyPrefix + id;
        // 1. 从redis中查询商铺缓存  （以json形式存储）
        String cacheJson = stringRedisTemplate.opsForValue().get(key);
        // 2. 判断是否存在
        if (StrUtil.isNotBlank(cacheJson)){
            // 3. 存在，直接返回
            return JSONUtil.toBean(cacheJson, type);
        }
        // 判断命中是否是空值
        if(cacheJson != null){
            //说明是缓存空值"" 返回错误 穿透结果
            return null;
        }
        // 4. 不存在，根据id查询数据库
        R r = dbFallback.apply(id);
        // 5. 不存在，返回错误
        if(r == null){
            // 将空值写入redis （避免缓存击穿问题）
            stringRedisTemplate.opsForValue().set(key,"", RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES);
            // 返回错误信息
            return null;
        }
        // 6. 存在，写入redis
        set(key, r, time, unit);
        // 7. 返回数据
        return r;
    }

    /**
    *@Description: 查询+解决缓存击穿 => 逻辑过期
    *@Param: [keyPrefix, id, type, time, unit, dbFallback]
    *@return: R
    */
    public <R,ID> R queryWithLogicExpire(String keyPrefix, ID id, Class<R> type, Long time, TimeUnit unit, Function<ID,R> dbFallback) {
        String key = keyPrefix + id;
        // 1. 从redis中查询
        String cacheJson = stringRedisTemplate.opsForValue().get(key);
        // 2. 判断是否存在
        if (StrUtil.isBlank(cacheJson)) {
            //未命中 返回空
            return null;
        }
        // 3. 存在，反序列化为对象
        RedisData redisData = JSONUtil.toBean(cacheJson, RedisData.class);
        R r = JSONUtil.toBean((JSONObject) redisData.getData(), type);
        LocalDateTime expireTime = redisData.getExpireTime();
        // 4. 判断是否过期
        if(!expireTime.isAfter(LocalDateTime.now())){
            // 5.1 未过期 返回
            return r;
        }
        // 5.2 过期，需要缓存重建
        // 6. 缓存重建
        // 6.1 获取互斥锁
        String lockKey = RedisConstants.LOCK_SHOP_KEY+id;
        boolean isLock = tryLock(lockKey);
        // 6.2 判断是否获取锁成功
        // 6.3 成功 开启线程执行重建过程
        if(isLock){
            //可以在次再次检测redis缓存是否过期，doublecheck 匿名内部类
            CACHE_REBUILD_EXXECUTOR.submit(new Runnable() {
                @Override
                public void run() {
                    // 查询数据库
                    R curR = dbFallback.apply(id);
                    //写入redis
                    CacheClient.this.setWithLogicExpire(key, curR, time, unit);
                    //释放锁
                    CacheClient.this.unLock(lockKey);
                }
            });
        }
        // 6.4 返回过期商品信息
        return r;
    }

    private boolean tryLock(String key){
        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", RedisConstants.LOCK_SHOP_TTL, TimeUnit.SECONDS);
        return BooleanUtil.isTrue(flag);   //转成基本类型返回，如果直接返回，拆箱的时候可能会造成空指针
    }

    private void unLock(String key){
        stringRedisTemplate.delete(key);
    }

}
```

#### 常用文件夹分层：

- pojo
  - vo （与前端交互的所有对象，包括接参和返回）
  - query （查询的筛选条件，前端传参和后端内部传参通用）
  - entity （数据库表基础对象）
  - dto（后端内部传输用，例如多张表字段合并到一个对象）

分层领域模型规约：

DO（Data Object）：此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。
DTO（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。
BO（Business Object）：业务对象，可以由 Service 层输出的封装业务逻辑的对象。
Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。
VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。
版权来自：

![在这里插入图片描述](https://img-blog.csdnimg.cn/5fe9f66c7914423ca07602348ea1d686.png)

面对这个图，让我们先从承上启下的DTO开始入手

DTO（Data Transfer Object）数据传输对象

这个传输通常指的前后端之间的传输

DTO是一个比较特殊的对象，他有两种存在形式：

在后端，他的存在形式是java对象，也就是在controller里面定义的那个东东，通常在后端不需要关心怎么从json转成java对象的，这个都是由一些成熟的框架帮你完成啦，比如spring框架

在前端，他的存在形式通常是js里面的对象（也可以简单理解成json），也就是通过ajax请求的那个数据体

这也是为什么把他画成横跨两层的原因

这里可能会遇到个问题，现在微服务盛行，服务和服务之间调用的传输对象能叫DTO吗？
我的理解是看情况
DTO本身的一个隐含的意义是要能够完整的表达一个业务模块的输出
如果服务和服务之间相对独立，那就可以叫DTO
如果服务和服务之间不独立，每个都不是一个完整的业务模块，拆开可能仅仅是因为计算复杂度或者性能的问题，那这就不能够叫做DTO，只能是BO

VO（Value Object）值对象
VO就是展示用的数据，不管展示方式是网页，还是客户端，还是APP，只要是这个东西是让人看到的，这就叫VO
VO主要的存在形式就是js里面的对象（也可以简单理解成json）VO和DTO的区别
主要有两个区别
一个是字段不一样，VO根据需要会删减一些字段
另一个是值不一样，VO会根据需要对DTO中的值进行展示业务的解释

PO（Persistant Object）持久对象
PO比较好理解
简单说PO就是数据库中的记录，一个PO的数据结构对应着库中表的结构，表中的一条记录就是一个PO对象
通常PO里面除了get，set之外没有别的方法
对于PO来说，数量是相对固定的，一定不会超过数据库表的数量
等同于Entity，这俩概念是一致的

BO（Business Object）业务对象
BO就是PO的组合
简单的例子比如说PO是一条交易记录，BO是一个人全部的交易记录集合对象
复杂点儿的例子PO1是交易记录，PO2是登录记录，PO3是商品浏览记录，PO4是添加购物车记录，PO5是搜索记录，BO是个人网站行为对象
BO是一个业务对象，一类业务就会对应一个BO，数量上没有限制，而且BO会有很多业务操作，也就是说除了get，set方法以外，BO会有很多针对自身数据进行计算的方法
为什么BO也画成横跨两层呢？原因是现在很多持久层框架自身就提供了数据组合的功能，因此BO有可能是在业务层由业务来拼装PO而成，也有可能是在数据库访问层由框架直接生成
很多情况下为了追求查询的效率，框架跳过PO直接生成BO的情况非常普遍，PO只是用来增删改使用
BO和DTO的区别
这两个的区别主要是就是字段的删减
BO对内，为了进行业务计算需要辅助数据，或者是一个业务有多个对外的接口，BO可能会含有很多接口对外所不需要的数据，因此DTO需要在BO的基础上，只要自己需要的数据，然后对外提供
在这个关系上，通常不会有数据内容的变化，内容变化要么在BO内部业务计算的时候完成，要么在解释VO的时候完成DO呢，标题不是还有个DO么？
上面这些概念基本上已经涵盖了全部的流程，DO只是跟其中一个概念相同
但是跟哪个概念相同呢？
现在主要有两个版本
一个是阿里巴巴的开发手册中的定义
DO（ Data Object）这个等同于上面的PO
另一个是在DDD（Domain-Driven Design）领域驱动设计中
DO（Domain Object）这个等同于上面的BO
最后，让我们再说说实际应用
这几个概念很完整，我们在用的时候是必须按这个来做吗？
当然不是的，系统和系统的复杂度不同，协作水平不同，完全没有必要教条主义，这些概念全上
上哪些概念，省哪些，我给一些实际建议
1，PO这个没法省，不管叫PO还是Entity，怎么着都得有
2，一些工具类的系统和一些业务不是很复杂的系统DTO是可以和BO合并成一个，当业务扩展的时候注意拆分就行
3，VO是可以第一个优化掉的，展示业务不复杂的可以压根儿不要，直接用DTO

版权来自http://t.csdn.cn/AfURa



## 优惠卷秒杀

**全局唯一 ID**、**实现优惠券秒杀下单**、**超卖问题**、**一人一单**、**分布式锁**、**Redis 优化秒杀**、**Redis 消息队列实现异步秒杀**

全局 ID 生成器，是一种在分布式系统下用来生成全局唯一 ID 的工具，一般要满足下列特性

为了增加 ID 的安全性，我们可以不直接使用 Redis 自增的数值，而是拼接一些其它信息![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/bc26ce89b3714be5ad8ea0829eb81b6e.png)

为了增加 ID 的安全性，我们可以不直接使用 Redis 自增的数值，而是拼接一些其它信息

**全局唯一 ID 生成策略**：

- UUID
- Redis 自增
- snowflake 算法
- 数据库自增

**Redis 自增 ID 策略**：

- 每天一个 key，方便统计订单量
- ID 构造是 时间戳 + 计数器

#### 超卖问题

正常情况下，线程 1 与线程 2 互不干扰。例如库存为 1，线程 1 查询库存后扣减；线程 2 查询库存发现为 0，故报错（不扣减）

正常情况下，线程 1 与线程 2 互不干扰。例如库存为 1，线程 1 查询库存后扣减；线程 2 查询库存发现为 0，故报错（不扣减）![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/353b7dd46a004d51b52a75af9063cc40.png)

解决办法：

##### 加锁

超卖问题是典型的多线程安全问题，针对这一问题的常见解决方案就是加锁：

悲观锁

认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。
例如 Synchronized、Lock 都属于悲观锁
乐观锁

认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时去判断有没有其它线程对数据做了修改。

如果没有修改则认为是安全的，自己才更新数据。

如果已经被其它线程修改说明发生了安全问题，此时可以重试或异常


乐观锁的关键是判断之前查询得到的数据是否有被修改过，常见的处理方式有两种：**版本号** 和 **CAS**

给数据添加一个 version，当该数据被修改时，version 数值就会被加一。

比如下图的情况：线程一修改过数据，version 已经变成了 2；线程二再去查找 version，发现已经不为 1 了，不会再修改数据了![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/247913db761a40aab2b447c1e8918863.png)

> - **CAS 方式**（**Compare And Swap**）

这里用库存值代替了上面的 version。![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/a8f4eb0819d748dfaf3d48d3a9f7438e.png)

#### 一人一单

![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/8dbfa1c842ec4ee884108a4a883cdee6.png)

### 分布式锁的原理

------

**分布式锁**：满足分布式系统或集群模式下多进程可见并且互斥的锁。

![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/29645cf6d5b945139826847e39d9be6d.png)

分布式锁的**特点**：**多进程可见**、**互斥**、**高可用**、**高性能**（高并发）、**安全性** …

**非阻塞式获取锁**

在获取锁失败后有两种机制，一种是阻塞时获取锁，另一种是非阻塞式获取锁

这里我们使用非阻塞式获取锁![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/32f10534476e4e848f2804c5b6b0d8d2.png)



#### 锁的误删问题

存在一种极端情况，线程一获取锁之后因为其他原因导致业务阻塞，以至于超时释放了锁。

之后线程二拿到了锁，恰好在此时，线程一阻塞结束且业务完成了，线程一就直接释放锁（我们这里的释放锁的处理就是 Del key）。

此时，线程二的锁被释放了（因为删除的就是它的锁）。

恰好此时线程三也去获取锁，因为锁已经被删除了，它也可以执行业务了。

这样就造成两个线程在同时执行业务了。这样也就没办法保证一人一票的业务了。

类似于你解自行车锁，解半天解不开气的直接砸了锁，砸完后锁开了，发现不是自己的自行车的这种情况。

解决办法就是在线程尝试获取锁的同时存入线程标识，在释放锁之前判断是否是自己的线程标识![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/25eadf4331de4542a647684ab2256169.png)

#### 锁的原子操作问题![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/62423c20e0aa464eb8e2760c15bc93e6.png)

线程 1 执行业务完成后，成功判断了 “当前 Redis 中的线程标识 和 获取锁时存入 Redis 的线程标识”，发现是两标识是相同的，去执行释放锁的操作的时候发生了阻塞（比如 JVM 中的垃圾回收）。

又因为阻塞时长太长的缘故，锁自行释放了（超时释放锁）。

此时线程 2 去拿到了锁，并执行业务。

在执行业务的过程中，线程 1 阻塞结束，因为之前已经进行过判断了，它已经确认锁是自己的锁了，故去释放锁，但是这个锁实际上是线程 2 的。（此处 key 值是唯一的，我们之前加的标识在 value 中，但线程 1 已经判断过不会再确认 value 中的线程标识了，所以线程 1 可以成功删除 key，即释放锁）

结果就是线程 3 也可以获取到锁，然后执行业务了。此时，就再一次出现了两个线程在同时执行业务的情况。

显然，这是判断标识操作和释放操作是两个动作造成的，要想避免这种现象，就必须要确保这俩个动作是也原子性的操作，必须同时执行，不可以有间隔。
**Lua 脚本解决多条命令原子性的问题**

```lua
-- 1. 参数列表
-- 1.1 优惠券id
local voucherId = ARGV[1]
-- 1.2 用户id
local userId = ARGV[2]
-- 1.3 订单id
local orderId = ARGV[3]
--2.数据key
-- 2.1 库存key
local stockKey = 'seckill:stock:' .. voucherId
-- 2.2 订单key
local orderKey = 'seckill:order:' .. voucherId

--3. 脚本业务
--3.1 判断库存是否充足
if( tonumber(redis.call('get',stockKey))  <= 0) then
    return 1
end

--3.2 判断用户是否下单
if( redis.call('sismember',orderKey,userId) == 1 ) then
    return 2
end

-- 扣库存，保存用户
redis.call('incrby',stockKey,-1)
redis.call('sadd',orderKey,userId)

-- 发送消息到stram消息队列 (消费组模式)
redis.call('xadd', 'stream.order', '*', 'userId', userId, 'voucherId', voucherId, 'id', orderId)

return 0
```

```lua
--比较线程标识与锁中的标识是否一致
if (redis.call('get', KEYS[1]) == ARGV[1]) then
    --释放锁
    return redis.call('del',KEYS[1])
end
return 0
```

#### Redisson 分布式锁

基于 setnx 实现的分布式锁存在下面的问题

不可重入：同一个线程无法多次获取同一把锁
不可重试：获取锁只尝试一次就返回 false，没有重试机制
超时释放：锁超时释放虽然可以避免死锁，但如果是业务执行耗时较长，也会导致锁释放，存在安全隐患
主从一致性：如果 Redis 提供了主从集群，主从延同步在延迟，当主机宕机时，如果从机同步主机中的数据，则会出现锁失效。
Redisson 是一个在 Redis 的基础上实现的 Java 驻内存数据网格（In-Memory Data Grid）。

它不仅提供了一系列的分布式的 Java 常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。
分布式锁（Lock）和同步器（Synchronizer）

可重入锁（Reentrant Lock）
公平锁（Fair Lock）
联锁（MultiLock）
红锁（RedLock）
读写锁（ReadWriteLock）
信号量（Semaphore）
可过期性信号量（PermitExpirableSemaphore）
闭锁（CountDownLatch）

编写Lua脚本 上方代码

![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/9aff901f113846d89e7716191d8b7e3c.png)


**小结**：Redisson 分布式锁原理

- **可重入**：利用 hash 结构记录线程 id 和重入次数
- **可重试**：利用信号量和 PubSub 功能实现等待、唤醒，获取锁失败的重试机制
- **超时续约**：利用 watchDog，每隔一段时间（releaseTime / 3），重置超时时间
- 不可重入Redis 分布式锁
  原理：利用 setnx 的互斥性；利用 ex 避免死锁；释放锁时判断线程标示
  缺陷：不可重入、无法重试、锁超时失效
  可重入的 Redis 分布式锁
  原理：利用 hash 结构，记录线程标示和重入次数；利用 watchDog 延续锁时间；利用信号量控制锁重试等待
  缺陷：Redis 宕机引起锁失效问题
  Redisson 的 multiLock
  原理：多个独立的 Redis 节点，必须在所有节点都获取重入锁，才算获取锁成功
  缺陷：运维成本高、实现复杂
  ![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/75a75cba7c4b41e5aaf5950f6a3e37ee.png)

![在这里插入图片描述](https://gitee.com/yrki/oumuanode/raw/master/https://gitee.com/yrki/oumuanode/720a60386e384959bc675e48df3e27f8.png)



**秒杀业务的优化思路是什么**？

- 先利用 Redis 完成库存余量、一人一单判断，完成抢单业务
- 再将下单业务放入阻塞队列，利用独立线程异步下单

**基于阻塞队列的异步秒杀存在哪些问题？**

- 内存限制问题

- 数据安全问题

  #### 

#### 秒杀的异步优化

------

最简单的消息队列模型包括 3 个角色

- 消息队列：存储和管理消息，也被称为消息代理（Message Broker）
- 生产者：发送消息到消息队列
- 消费者：从消息队列获取消息并处理消息

Redis 提供了三种不同的方式来实现消息队列：

- **List** 结构：基于 List 结构模拟消息队列
- **PubSub**：基本的点对点消息模型
- **Stream**：比较完善的消息队列模型



#### 消费组模式

消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。

其具备下列特点：

消息分流：队列中的 消息会分流给组内不同的消费者，而不是重复消费，从而加快消息处理的速度。

消息标示：消费者组会维护一个标示，记录最后一个被处理的消息，即使消费者宕机重启，还会从标示之后读取消息，确保每一个消息都会被消费。（解决漏读问题）

消息确认：消费者获取消息后，消息处于 pending 状态，并存入一个 pending-list。

当处理完成后需要通过 XACK 命令来确认消息，标记消息为已处理，才会从 pending-list 中移除。（解决消息丢失问题）


#### 完整代码

controller

```java
@RestController
@RequestMapping("/voucher-order")
public class VoucherOrderController {

    @Autowired
    private IVoucherOrderService voucherOrderService;

    @PostMapping("seckill/{id}")
    public Result seckillVoucher(@PathVariable("id") Long voucherId) {
        return voucherOrderService.seckKillVoucher(voucherId);
    }
}
```

接口

```java
public interface IVoucherOrderService extends IService<VoucherOrder> {

    /**
    *@Description: 优惠券抢购
    *@Param: [voucherId]
    *@return: com.hmdp.dto.Result
    */
    Result seckKillVoucher(Long voucherId);

    Result createVoucherOrder(Long voucherId);
}
```

业务类 项目精华重点

```java
@Slf4j
@Service
public class VoucherOrderServiceImpl extends ServiceImpl<VoucherOrderMapper, VoucherOrder> implements IVoucherOrderService {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Autowired
    private ISeckillVoucherService seckillVoucherService;

    @Autowired
    private RedisIdWorker redisIdWorker;

    @Autowired
    private RedissonClient redissonClient;

    //    private BlockingDeque<VoucherOrder> orderTasks = (BlockingDeque<VoucherOrder>) new ArrayBlockingQueue<VoucherOrder>(1024 * 1024);  //阻塞队列
    //private static ExecutorService SECKILL_ORDER_EXECUTOR = Executors.newSingleThreadExecutor();

    // 只有redis版本>5时才支持redis流  redis-server --version  Redis server v=3.0.504(所以暂时将此方法注释掉，避免springboot启动报错)
    /*
    @PostConstruct
    private void init(){
        SECKILL_ORDER_EXECUTOR.submit(()->{
            while(true){
                try{
                    // 1.从消息队列中拿消息  XREADGROUP GROUP g1 c1  COUNT 1 BLOCK 2000 STREAMS streams.order >   //g1组的c1消费者
                    List<MapRecord<String, Object, Object>> list = stringRedisTemplate.opsForStream().read(
                            Consumer.from("g1", "c1"),
                            StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)),
                            StreamOffset.create("stream.orders", ReadOffset.lastConsumed())
                    );
                    if(list == null || list.isEmpty()){
                        // 没有消息，继续下一次循环
                        continue;
                    }
                    // 解析消息
                    MapRecord<String, Object, Object> record = list.get(0);
                    Map<Object, Object> value = record.getValue();  // 键值对的值
                    VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);

                    // 获取消息成功，下单
                    handleVouncherOrder(voucherOrder);
                    //ack确认
                    stringRedisTemplate.opsForStream().acknowledge("streams.order","g1",record.getId());
                }catch (Exception e){
                    log.error("处理订单异常",e);
                    // 从pendinglist 里取消息，重新执行
                    handlePendingList();
                }
            }

        });
    }
    */

    // 阻塞队列方案的线程执行方法
//    private class VoucherOrderHandle implements Runnable{
//        @Override
//        public void run() {
//            while(true){
//                try {
//                    // 1. 获取队列中的订单信息
//                    VoucherOrder voucherOrder = orderTasks.take();
//                    // 2. 创建订单
//                    handleVouncherOrder(voucherOrder);
//                } catch (Exception e) {
//                    e.printStackTrace();
//                    log.error("处理订单异常",e);
//                }
//
//            }
//        }
//    }

    private void handlePendingList(){
        while(true){
            try{
                // 1.从pending-list中拿消息  XREADGROUP GROUP g1 c1  COUNT 1 BLOCK 2000 STREAMS streams.order 0   //g1组的c1消费者
                List<MapRecord<String, Object, Object>> list = stringRedisTemplate.opsForStream().read(
                        Consumer.from("g1", "c1"),
                        StreamReadOptions.empty().count(1),
                        StreamOffset.create("stream.orders", ReadOffset.from("0"))
                );
                if(list == null || list.isEmpty()){
                    // 没有读到，说明pending-list里没有异常消息 结束循环
                    break;
                }
                // 解析消息
                MapRecord<String, Object, Object> record = list.get(0);
                Map<Object, Object> value = record.getValue();  // 键值对的值
                VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);

                // 获取消息成功，下单
                handleVouncherOrder(voucherOrder);
                //ack确认
                stringRedisTemplate.opsForStream().acknowledge("streams.order","g1",record.getId());
            }catch (Exception e){
                log.error("处理pending-list订单异常",e);
            }
        }
    }

    private void handleVouncherOrder(VoucherOrder voucherOrder) throws InterruptedException {
        // 1. 获取用户（因为是从线程池中新开的线程，不是主线程，从UserHolder取不到用户信息，所以只能从voucherOrder中取）
        Long userId = voucherOrder.getUserId();
        // 2. 创建锁对象 (其实不加锁也可以，因为redis做了并发的避免，但此处加只是做个兜底（虽然这种可能性几乎没有）)
        RLock lock = redissonClient.getLock("lock:order:" + userId);
        boolean isLock = lock.tryLock();
        if(!isLock){
            log.error("不允许重复下单");
            return;
        }
        //TODO 写入到数据库的一些操作(即 createVoucherOrder 但要注意的是如果在此处获取代理对象会失效，因为获取代理对象的底层用的ThreadLocal，而我们此时是在线程池里的新线程执行的：解决方法：1.将代理对象传参进来 2.将代理对象变成类的成员变量)
    }

    //秒杀lua脚本
    private static final DefaultRedisScript<Long> SECKILL_SCRIPT;
    static {
        SECKILL_SCRIPT = new DefaultRedisScript<>();
        SECKILL_SCRIPT.setLocation(new ClassPathResource("./lua/seckill.lua"));
        SECKILL_SCRIPT.setResultType(Long.class);
    }

    //基于redis完成秒杀资格判断（秒杀优化）+Stream消息队列
    @Override
    public Result seckKillVoucher(Long voucherId) {
        // 1. 查寻优惠券
        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
        if(voucher == null){
            return Result.fail("优惠券信息错误!");
        }
        // 2. 判断秒杀是否开始
        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
            return Result.fail("秒杀尚未开始!");
        }
        // 3. 判断秒杀是否结束
        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
            return Result.fail("秒杀已经结束!");
        }


        Long userId = UserHolder.getUser().getId();
        long orderId = redisIdWorker.nexId("order");
        // 1.执行lua脚本
        Long result = stringRedisTemplate.execute(
                SECKILL_SCRIPT,
                Collections.EMPTY_LIST,
                voucherId.toString(),
                userId.toString(),
                String.valueOf(orderId)
        );
        int resultValue = result.intValue();
        // 2.判断结果是否为0  0为有购买资格
        if(resultValue != 0){
            return Result.fail(resultValue==1?"库存不足":"不能重复下单");
        }
        // 3. 保存到数据库的信息通过消息队列放到线程池中执行

        // 4. 返回订单ID
        return Result.ok(orderId);
    }



//    @Override
//    public Result seckKillVoucher(Long voucherId) {
//        // 1. 查寻优惠券
//        SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
//        if(voucher == null){
//            return Result.fail("优惠券信息错误!");
//        }
//        // 2. 判断秒杀是否开始
//        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
//            return Result.fail("秒杀尚未开始!");
//        }
//        // 3. 判断秒杀是否结束
//        if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
//            return Result.fail("秒杀已经结束!");
//        }
//        // 4. 判断库存是否充足
//        if (voucher.getStock()<1) {
//            return Result.fail("库存不足!");
//        }
//
//        Long userID = UserHolder.getUser().getId();
//        //**************************************** 单机模式下的锁机制 ********************************************************************
//
////        synchronized(userID.toString().intern()) {
////            /*
////            Q4: 为什么不能直接return createVoucherOrder(voucherId)？会出现什么问题
////            A: 因为这个createVoucherOrder使用了@Transactional通过AOP实现事务的控制，
////               而直接 return createVoucherOrder(voucherId) 本质其实是 return this.createVoucherOrder(voucherId)
////               是直接调用的方法，而不是Spring管理的对象
////               Spring AOP是通过动态代理对象实现的，而直接那样相当于直接调用原本方法，！！没有实现事务的操作！！
////
////               所以要通过 AopContext.currentProxy(); 方法获取当前对象的代理对象，然后调用代理方法，才能实现事务控制
////
////               除此之外，还要有额外两步骤：
////                 1.  maven中导入  aspectjweaver 包
////                 <!--        代理的模式-->
////                <dependency>
////                    <groupId>org.aspectj</groupId>
////                    <artifactId>aspectjweaver</artifactId>
////                </dependency>
////
////                2. 在启动类中加入注解 @EnableAspectJAutoProxy(exposeProxy = true)   //代理对象可以暴露（默认为false）
////             */
////            // 获取代理对象(事务)
////            IVoucherOrderService proxy = (IVoucherOrderService)AopContext.currentProxy();
////            return proxy.createVoucherOrder(voucherId);
////        }
//
//        //************************************************************************************************************
//
//        //**************************************** 集群模式下使用分布式锁 ********************************************************************
//
//        //创建锁对象
//
//        //自己实现的分布式锁
////        SimpleRedisLock lock = new SimpleRedisLock("order:" + userID, stringRedisTemplate);
////        boolean isLock = lock.tryLock(1200);
//
//        //已有框架redisson提供的锁实现
//        RLock lock = redissonClient.getLock("lock:order:" + userID);   //可重入锁
//        boolean isLock = lock.tryLock();
//        //判断锁是否获取成功
//        if(!isLock){
//            // 获取锁失败,返回错误或重试
//            return Result.fail("不允许重复下单");
//        }
//        try {
//            IVoucherOrderService proxy = (IVoucherOrderService)AopContext.currentProxy();
//            return proxy.createVoucherOrder(voucherId);
//        } finally {
//            lock.unlock();
//        }
//
//        //************************************************************************************************************
//    }

    @Transactional
    public Result createVoucherOrder(Long voucherId){   //synchronized（悲观锁）在方法上锁的对象是this  ->  所有用户加的是同一把锁  ->  应该以当前用户id加锁，这样不同用户在一人一单查询时各自查各自的
        // 5. 一人一单   (   一人一单功能   )
        Long userID = UserHolder.getUser().getId();

        /*
         Q1: 为什么锁要toString()
         A: 每一次请求userID都是一个全新的对象，对象变了，锁就变了,而我们是希望值一样的用一把锁，所以用了toString()

         Q2: toString()就能保证以值来加锁么？  不行❌
         A: toString 底层是new了一个String，所以只调用toString()其实每次返回的还是新的对象  =>  所以还要调用intern()方法
            intern()方法：返回字符串对象的规范表示 就是初始化了一个为空的String Pool，equals为true 就返回池中对象，否则生成新的String对象，加入池中并返回

            It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.

         锁的范围变小（同一用户用一把锁），系统性能提升

         Q3: 为什么不能在这个方法里用synchronized
         A： 因为锁在括号结束后就释放了，而事务要在整个函数执行完才提交（此时事务的级别是 可重复读），所以在 放锁 提交事务 之间如果该用户再次进行一人一单查询，会因为事务未提交而显示未有订单 => 并发问题
            所以要将synchronized 放在上面
         */
//        synchronized(userID.toString().intern()){
        // 5.1 查询订单
        int count = query().eq("user_id", userID).eq("voucher_id", voucherId).count();
        // 5.2 判断是否存在
        if(count > 0) {
            //用户已经买过
            return Result.fail("用户已经购买过一次！");
        }

        // 6. 扣减库存  (   超卖问题   )
        boolean success = seckillVoucherService.update()   //其实也用了sql语句update的行锁机制，数据库层面加了锁
                .setSql("stock = stock-1")
                .eq("voucher_id", voucherId).gt("stock",0)   // where id = ? and stock > 0  乐观锁(不加锁，在数据更新时判断是否有其他线程在修改)(CAS实现)
                .update();
        if(!success){
            return Result.fail("库存不足!");
        }

        // 7. 创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        long orderID = redisIdWorker.nexId("order");
        voucherOrder.setId(orderID);
        voucherOrder.setUserId(userID);
        voucherOrder.setVoucherId(voucherId);
        // 8. 返回订单id
        save(voucherOrder);
        return Result.ok(orderID);
//        }
    }
}
```



#### 添加优惠券

#### 

完整代码

controller

```java
@RestController
@RequestMapping("/voucher")
public class VoucherController {

    @Resource
    private IVoucherService voucherService;

    /**
     * 新增普通券
     * @param voucher 优惠券信息
     * @return 优惠券id
     */
    @PostMapping
    public Result addVoucher(@RequestBody Voucher voucher) {
        voucherService.save(voucher);
        return Result.ok(voucher.getId());
    }

    /**
     * 新增秒杀券
     * @param voucher 优惠券信息，包含秒杀信息
     * @return 优惠券id
     */
    @PostMapping("seckill")
    public Result addSeckillVoucher(@RequestBody Voucher voucher) {
        voucherService.addSeckillVoucher(voucher);
        return Result.ok(voucher.getId());
    }

    /**
     * 查询店铺的优惠券列表
     * @param shopId 店铺id
     * @return 优惠券列表
     */
    @GetMapping("/list/{shopId}")
    public Result queryVoucherOfShop(@PathVariable("shopId") Long shopId) {
       return voucherService.queryVoucherOfShop(shopId);
    }
}
```

接口

```java
public interface IVoucherService extends IService<Voucher> {

    Result queryVoucherOfShop(Long shopId);

    void addSeckillVoucher(Voucher voucher);
}
```

业务类

```java
@Service
public class VoucherServiceImpl extends ServiceImpl<VoucherMapper, Voucher> implements IVoucherService {

    @Resource
    private ISeckillVoucherService seckillVoucherService;

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Override
    public Result queryVoucherOfShop(Long shopId) {
        // 查询优惠券信息
        List<Voucher> vouchers = getBaseMapper().queryVoucherOfShop(shopId);
        // 返回结果
        return Result.ok(vouchers);
    }

    @Override
    @Transactional
    public void addSeckillVoucher(Voucher voucher) {
        // 保存优惠券
        save(voucher);
        // 保存秒杀信息
        SeckillVoucher seckillVoucher = new SeckillVoucher();
        seckillVoucher.setVoucherId(voucher.getId());
        seckillVoucher.setStock(voucher.getStock());
        seckillVoucher.setBeginTime(voucher.getBeginTime());
        seckillVoucher.setEndTime(voucher.getEndTime());
        seckillVoucherService.save(seckillVoucher);

        //将秒杀优惠券的 库存  信息保存到redis中
        stringRedisTemplate.opsForValue().set(RedisConstants.SECKILL_STOCK_KEY+voucher.getId(), String.valueOf(voucher.getStock()));
    }
}
```

```java
/**
 * <p>
 * 秒杀优惠券表，与优惠券是一对一关系 服务实现类
 * </p>
 *
 * @author
 * @since 2023-01-04
 */
@Service
public class SeckillVoucherServiceImpl extends ServiceImpl<SeckillVoucherMapper, SeckillVoucher> implements ISeckillVoucherService {

}
```

#### 达人探店功能

#### 点赞功能

案例：完善点赞功能
需求：

同一个用户只能点赞一次，再次点击则取消点赞
如果当前用户已经点赞，则点赞按钮高亮显示（前端已实现，判断字段 Blog 类的 isLike 属性）
实现步骤：

给 Blog 类中添加一个 isLike 字段，标示是否被当前用户点赞
修改点赞功能，利用 Redis 的 Set 集合判断是否点赞过，未点赞过则点赞数 + 1，已点赞过则点赞数 - 1
修改根据 id 查询 Blog 的业务，判断当前登录用户是否点赞过，赋值给 isLike 字段
修改分页查询 Blog 业务，判断当前登录用户是否点赞过，赋值给 isLike 字段

滚动分页查询

#### 关注推送

------

##### Feed 流分析

Feed 流产品有两种常见模式：

Timeline：不做内容筛选，简单的按照内容发布时间排序，常用于好友或关注。

例如朋友圈

优点：信息全面，不会有缺失。并且实现也相对简单
缺点：信息噪音较多，用户不一定感兴趣，内容获取效率低
智能排序：利用智能算法屏蔽掉违规的、用户不感兴趣的内容。

推送用户感兴趣信息来吸引用户

优点：投喂用户感兴趣信息，用户粘度很高，容易沉迷
缺点：如果算法不精准，可能起到反作用
本例中的个人页面，是基于关注的好友来做 Feed 流，因此采用 Timeline 的模式。

该模式的实现方案有三种：拉模式、推模式、推拉结合
**拉模式**：也叫做读扩散

**推模式**：也叫做写扩散。

**推拉结合模式**：也叫做读写混合，兼具推和拉两种模式的优点

#### 上述功能完整代码实现

```java
@RestController
@RequestMapping("/blog")
public class BlogController {

    @Autowired
    private IBlogService blogService;

    @PostMapping
    public Result saveBlog(@RequestBody Blog blog) {
        return blogService.saveBlog(blog);
    }

    @PutMapping("/like/{id}")
    public Result likeBlog(@PathVariable("id") Long id) {
        return blogService.likeBlog(id);
    }

    @GetMapping("/of/me")
    public Result queryMyBlog(@RequestParam(value = "current", defaultValue = "1") Integer current) {
        // 获取登录用户
        UserDTO user = UserHolder.getUser();
        // 根据用户查询
        Page<Blog> page = blogService.query()
                .eq("user_id", user.getId()).page(new Page<>(current, SystemConstants.MAX_PAGE_SIZE));
        // 获取当前页数据
        List<Blog> records = page.getRecords();
        return Result.ok(records);
    }

    @GetMapping("/hot")
    public Result queryHotBlog(@RequestParam(value = "current", defaultValue = "1") Integer current) {
        return blogService.queryHotBlog(current);
    }

    @GetMapping("/{id}")
    public Result queryBlog(@PathVariable("id") Long id){
        return blogService.queryBlogById(id);
    }

    @GetMapping("/likes/{id}")
    public Result queryBlogLikes(@PathVariable("id") Long id){
        return blogService.queryBlogLikes(id);
    }

    @GetMapping("/of/user")
    public Result queryBlogByUserId(@RequestParam(value = "current",defaultValue = "1") Integer current, @RequestParam("id") Long id){
        Page<Blog> page = blogService.query().eq("user_id", id).page(new Page<>(current, SystemConstants.MAX_PAGE_SIZE));
        return Result.ok(page.getRecords());
    }

    /**
    *@Description: 滚动分页查询收件箱
    *@Param: [max] 上一次请求的最小时间戳(本次的最大时间)  [offset] 偏移量(上一次查询 score 为最小时间戳的个数)
    *@return: com.hmdp.dto.Result  List<Blog>:小于指定时间戳的笔记集合 mintime：本次查询的推送的最小时间戳 offset：偏移量
    */
    @GetMapping("/of/follow")
    public Result queryBlogOfFollow(@RequestParam(value = "lastId") Long max,@RequestParam(value = "offset",defaultValue = "0") Integer offset){
        return blogService.queryBlogOfFollow(max,offset);
    }

}
```

```java
public interface IBlogService extends IService<Blog> {

    public Result queryBlogById(Long id);

    public Result queryHotBlog(Integer current);

    public Result likeBlog(Long id);

    public Result queryBlogLikes(Long id);

    public Result saveBlog(Blog blog);

    public Result queryBlogOfFollow(Long max, Integer offset);
}
```

```java
@Service
public class BlogServiceImpl extends ServiceImpl<BlogMapper, Blog> implements IBlogService {

    @Autowired
    private IUserService userService;

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Autowired
    private IFollowService followService;

    @Override
    public Result saveBlog(Blog blog) {
        // 获取登录用户
        UserDTO user = UserHolder.getUser();
        blog.setUserId(user.getId());
        // 保存探店博文
        boolean isSuccess = save(blog);
        if(!isSuccess){
            return Result.fail("新增笔记失败!");
        }
        //将博客id发送给粉丝
        // 1. 查粉丝 select * from tb_follow where follow_user_id = userId
        Long userId = UserHolder.getUser().getId();
        List<Follow> follows = followService.query().eq("follow_user_id", userId).list();
        //推送笔记id给所有粉丝
        for(Follow follow:follows){
            // 获取粉丝id
            Long fancyId = follow.getId();
            // 推送
            String key = RedisConstants.FEED_KEY+userId;
            stringRedisTemplate.opsForZSet().add(key,blog.getId().toString(),System.currentTimeMillis());
        }
        // 返回id
        return Result.ok(blog.getId());
    }

    @Override
    public Result queryHotBlog(Integer current) {
        // 根据用户查询
        Page<Blog> page = query()
                .orderByDesc("liked")
                .page(new Page<>(current, SystemConstants.MAX_PAGE_SIZE));
        // 获取当前页数据
        List<Blog> records = page.getRecords();
        // 查询用户
        records.forEach(blog ->{
            queryBlogUser(blog);
            isBlogLiked(blog);
        });
        return Result.ok(records);
    }

    @Override
    public Result queryBlogById(Long id) {
        Blog blog = getById(id);
        if(blog == null){
            return Result.fail("博客不存在！");
        }
        queryBlogUser(blog);
        // 查询blog是否被点赞了
        isBlogLiked(blog);
        return Result.ok(blog);
    }

    /**
     *@Description: 判断博客是否被当前用户点了赞
     *@Param: [blog]
     *@return: void
     */
    private void isBlogLiked(Blog blog) {
        //因为首页也会调用这个函数，而查看首页时用户不一定会登录
        String key = RedisConstants.BLOG_LIKED_KEY+blog.getId();
        UserDTO user = UserHolder.getUser();
        if(user == null) {
            // 用户未登录，无需查询是否点赞
            return;
        }
        Double score = stringRedisTemplate.opsForZSet().score(key, user.getId().toString());
        blog.setIsLike(score != null);
    }

    /**
     *@Description: 查询博客的用户信息
     *@Param: [blog]
     *@return: void
     */
    private void queryBlogUser(Blog blog) {
        Long userId = blog.getUserId();
        User user = userService.getById(userId);
        blog.setName(user.getNickName());
        blog.setIcon(user.getIcon());
    }

    @Override
    public Result likeBlog(Long id) {
        String key = RedisConstants.BLOG_LIKED_KEY+id;
        //判断当前登录用户是否点赞了
        UserDTO user = UserHolder.getUser();
        Double score = stringRedisTemplate.opsForZSet().score(key, user.getId().toString());
        if(score == null){
            //未点赞，可以点赞
            // 修改点赞数量
            boolean isSuccess = update().setSql("liked = liked + 1").eq("id", id).update();
            if(isSuccess){
                stringRedisTemplate.opsForZSet().add(key,user.getId().toString(),System.currentTimeMillis());
            }
        }else{
            //已点赞，取消点赞
            boolean isSuccess = update().setSql("liked = liked - 1").eq("id", id).update();
            if(isSuccess){
                stringRedisTemplate.opsForZSet().remove(key, user.getId().toString());
            }
        }
        return Result.ok();
    }

    @Override
    public Result queryBlogLikes(Long id) {
        String key = RedisConstants.BLOG_LIKED_KEY+id;
        //1,查询top5的点赞用户zrange key 0 4
        Set<String> top5 = stringRedisTemplate.opsForZSet().range(key, 0, 4);
        if(top5 == null || top5.isEmpty()){
            return Result.ok(Collections.emptySet());
        }
        //2.解析出其中的用户id
        List<Long> ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());

        //3,根据用户id查询用户WHERE id IN(5,1)ORDER BY FIELD(id,5,1)
        String idStr = StrUtil.join(",",ids);

        List<UserDTO> userDTOS = userService.
        query().in("id",ids).last("ORDER BY FIELD(id,"+idStr+")").list()
        .stream().map(user -> BeanUtil.copyProperties(user, UserDTO.class))
                .collect(Collectors.toList());

        //4.返回
        return Result.ok(userDTOS);
    }

    @Override
    public Result queryBlogOfFollow(Long max, Integer offset) {
        Long userID = UserHolder.getUser().getId();
        String key = RedisConstants.FEED_KEY+userID;
        //查询收件箱  ZREVRANGEBYSCORE key max 0 offset count
        Set<ZSetOperations.TypedTuple<String>> typedTuples = stringRedisTemplate.opsForZSet().reverseRangeByScoreWithScores(key, 0, max, offset, 2);
        if(typedTuples == null || typedTuples.isEmpty()){
            return Result.ok();
        }
        //解析数据：blogId、minTime(时间戳)、offset 分数值等于最小值时间所有元素的个数
        List<Long> ids = new ArrayList<>(typedTuples.size());
        long minTime = 0;
        int offsetNew = 1;
        //一个或多个元组 ZSetOperations.TypedTuple
        for (ZSetOperations.TypedTuple<String> tuple : typedTuples) {
            ids.add(Long.valueOf(tuple.getValue()));
            //时间戳
            long time = tuple.getScore().longValue();
            if(time == minTime) offsetNew++;
            else{
                minTime = time;
                offsetNew = 1;
            }
        }
        //根据id查blog
        String idstr = StrUtil.join(",", ids);
        List<Blog> blogs = query().in("id", ids).last("ORDER BY FIELD(id," + idstr + ")").list();
        blogs.forEach(blog -> {
            queryBlogUser(blog);
            // 查询blog是否被点赞了
            isBlogLiked(blog);}
        );
        return Result.ok(new ScrollResult(blogs,minTime,offsetNew));
    }
}
```





#### 关注和取关共同关注

**案例**：实现关注和取关功能

**需求**：基于该表数据结构，实现两个接口

1. 关注和取关接口
2. 判断是否关注的接口

关注是 User 之间的关系，是博主与粉丝的关系，数据库中有一张 tb_follow 表来表示

#### 完整代码实现

```java
@RestController
@RequestMapping("/follow")
public class FollowController {

    @Autowired
    private IFollowService followService;

    @PutMapping("/{id}/{isfollow}")
    public Result follow(@PathVariable("id") Long followUserId, @PathVariable("isfollow") Boolean isFollow){
        return followService.follow(followUserId,isFollow);
    }

    @GetMapping("/or/not/{id}")
    public Result isFollow(@PathVariable("id") Long followUserId){
        return followService.isFollow(followUserId);
    }

    @GetMapping("/common/{id}")
    public Result followCommons(@PathVariable("id") Long id){
        return followService.followCommons(id);
    }


}
```

```java
public interface IFollowService extends IService<Follow> {

    public Result follow(Long followUserId, Boolean isFollow);

    public Result isFollow(Long followUserId);

    public Result followCommons(Long id);
}
```



```java
@Service
public class FollowServiceImpl extends ServiceImpl<FollowMapper, Follow> implements IFollowService {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Autowired
    private IUserService userService;


    @Override
    public Result follow(Long followUserId, Boolean isFollow) {
        Long userId = UserHolder.getUser().getId();
        String key = "follows:"+userId;
        // 判断是关注还是取关
        if (isFollow) {
            // 关注 新增数据
            Follow follow = new Follow();
            follow.setUserId(userId);
            follow.setFollowUserId(followUserId);
            follow.setCreateTime(LocalDateTime.now());
            boolean isSuccess = save(follow);
            if(isSuccess){
                // 放入redis
                stringRedisTemplate.opsForSet().add(key,followUserId.toString());
            }
        }else {
            // 取关 删除
            getBaseMapper().cancelFollow(userId, followUserId);
            stringRedisTemplate.opsForSet().remove(key,followUserId.toString());
        }
        return Result.ok();
    }

    @Override
    public Result isFollow(Long followUserId) {
        Long userId = UserHolder.getUser().getId();
        // 查询是否关注
        Integer count = query().eq("user_id", userId).eq("follow_user_id", followUserId).count();

        return Result.ok(count>0);
    }

    @Override
    public Result followCommons(Long id) {
        //1,获取当前用户
        Long userId = UserHolder.getUser().getId();
        String key = "follows:"+userId;
        String key2 = "follows:"+id;
        //2.求交集
        Set<String> intersect = stringRedisTemplate.opsForSet().intersect(key, key2);
        if(intersect == null || intersect.isEmpty()){
            return Result.ok(Collections.emptyList());
        }
        // 解析id，查询用户
        List<Long> ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());
        //查询用户
        List<UserDTO> users = userService.listByIds(ids)
                .stream().map(user -> BeanUtil.copyProperties(user, UserDTO.class))
                .collect(Collectors.toList());

        return Result.ok(users);
    }
}
```

#### GEO 附近搜索

##### 实现查找附近商铺功能

test类 redis 版本问题导致add()错误

```java
@Test
void loadShopData() {
    // 1.查询店铺信息
    List<Shop> list = shopService.list();
    // 2.把店铺分组，按照typeId分组，typeId一致的放到一个集合
    Map<Long, List<Shop>> map = list.stream().collect(Collectors.groupingBy(Shop::getTypeId));
    // 3.分批完成写入Redis
    for (Map.Entry<Long, List<Shop>> entry : map.entrySet()) {
        // 3.1.获取类型id
        Long typeId = entry.getKey();
        String key = SHOP_GEO_KEY + typeId;
        // 3.2.获取同类型的店铺的集合
        List<Shop> value = entry.getValue();
        List<RedisGeoCommands.GeoLocation<String>> locations = new ArrayList<>(value.size());
        // 3.3.写入redis GEOADD key 经度 纬度 member
        for (Shop shop : value) {
            // stringRedisTemplate.opsForGeo().add(key, new Point(shop.getX(), shop.getY()), shop.getId().toString());
            locations.add(new RedisGeoCommands.GeoLocation<>(
                    shop.getId().toString(),
                    new Point(shop.getX(), shop.getY())
            ));
        }
        stringRedisTemplate.opsForGeo().add(key, locations);
    }
}
```

#### 完整代码实现

```java
/**
 * 根据商铺类型分页查询商铺信息
 * @param typeId 商铺类型
 * @param current 页码
 * @return 商铺列表
 */
@GetMapping("/of/type")
public Result queryShopByType(
        @RequestParam("typeId") Integer typeId,
        @RequestParam(value = "current", defaultValue = "1") Integer current,
        @RequestParam(value = "x", required = false) Double x,
        @RequestParam(value = "y", required = false) Double y
) {
    return shopService.queryShopByType(typeId, current, x, y);
}
```

```java
Result queryShopByType(Integer typeId, Integer current, Double x, Double y);
```

```java
@Override
public Result queryShopByType(Integer typeId, Integer current, Double x, Double y) {
    // 1.判断是否需要根据坐标查询
    if (x == null || y == null) {
        // 不需要坐标查询，按数据库查询
        Page<Shop> page = query()
                .eq("type_id", typeId)
                .page(new Page<>(current, SystemConstants.DEFAULT_PAGE_SIZE));
        // 返回数据
        return Result.ok(page.getRecords());
    }

    // 2.计算分页参数
    int from = (current - 1) * SystemConstants.DEFAULT_PAGE_SIZE;
    int end = current * SystemConstants.DEFAULT_PAGE_SIZE;

    // 3.查询redis、按照距离排序、分页。结果：shopId、distance
    String key = SHOP_GEO_KEY + typeId;
    GeoResults<RedisGeoCommands.GeoLocation<String>> results = stringRedisTemplate.opsForGeo() // GEOSEARCH key BYLONLAT x y BYRADIUS 10 WITHDISTANCE
            .search(
                    key,
                    GeoReference.fromCoordinate(x, y),
                    new Distance(5000),
                    RedisGeoCommands.GeoSearchCommandArgs.newGeoSearchArgs().includeDistance().limit(end)
            );
    // 4.解析出id
    if (results == null) {
        return Result.ok(Collections.emptyList());
    }
    List<GeoResult<RedisGeoCommands.GeoLocation<String>>> list = results.getContent();
    if (list.size() <= from) {
        // 没有下一页了，结束
        return Result.ok(Collections.emptyList());
    }
    // 4.1.截取 from ~ end的部分
    List<Long> ids = new ArrayList<>(list.size());
    Map<String, Distance> distanceMap = new HashMap<>(list.size());
    list.stream().skip(from).forEach(result -> {
        // 4.2.获取店铺id
        String shopIdStr = result.getContent().getName();
        ids.add(Long.valueOf(shopIdStr));
        // 4.3.获取距离
        Distance distance = result.getDistance();
        distanceMap.put(shopIdStr, distance);
    });
    // 5.根据id查询Shop
    String idStr = StrUtil.join(",", ids);
    List<Shop> shops = query().in("id", ids).last("ORDER BY FIELD(id," + idStr + ")").list();
    for (Shop shop : shops) {
        shop.setDistance(distanceMap.get(shop.getId().toString()).getValue());
    }
    // 6.返回
    return Result.ok(shops);
}
```

##### 签到功能

```java
/**
*@Description: 用户签到
*@Param: []
*@return: com.hmdp.dto.Result
*/
@PostMapping("/sign")
public Result sign(){
    return userService.sign();
}



@GetMapping("/sign/count")
public Result signCount(){
    return userService.signCount();
}
```

```java
Result logout();

Result signCount();
```

```java
@Override
public Result signCount() {
    //获取当前用户
    Long userId = UserHolder.getUser().getId();
    // 获取日期 拼接Key
    LocalDateTime now = LocalDateTime.now();

    String format = now.format(DateTimeFormatter.ofPattern(":yyyyMM"));
    String key = RedisConstants.USER_SIGN_KEY + userId +format;
    //获取本月第几天
    int dayOfMonth = now.getDayOfMonth();
    //获取本月截止今天为止的所有的签到记录，返回是一个十进制的数字
    List<Long> result = stringRedisTemplate.opsForValue().bitField(
            key,
            BitFieldSubCommands.create().get(BitFieldSubCommands.BitFieldType.unsigned(dayOfMonth)).valueAt(0)
    );

    if (result == null || result.isEmpty()){
        //没有任何签到结果
        return Result.ok(0);
    }

    Long num = result.get(0);
    if (num == null || num == 0){
        return Result.ok(0);
    }
    //循环遍历
    int count = 0;
    while (true){
        //让这个数字与1做与运算，得到数字的最后一个bit位
        //判断这个bit位是否为0
        if ((num & 1) == 0){
            //如果0，说明未签到，结束
            break;
        }else {
            //如果不0，说明已签到，计数器+1
            count ++;
        }
        //把数字右移一位，抛弃最后一个bit位，继续下一个bit位
        num >>>= 1;
    }
    return Result.ok(count);
}
```

```java
@Override
public Result sign() {
    //获取当前用户
    Long userId = UserHolder.getUser().getId();
    // 获取日期 拼接Key
    LocalDateTime now = LocalDateTime.now();

    String format = now.format(DateTimeFormatter.ofPattern(":yyyyMM"));
    String key = RedisConstants.USER_SIGN_KEY + userId +format;

    // BitMap底层是基于String数据结构，因此其操作也都封装在字符串相关操作中
    int dayOfMonth = now.getDayOfMonth()-1;
    stringRedisTemplate.opsForValue().setBit(key,dayOfMonth,true);
    return Result.ok();
}
```

### 项目补充：

#### 上传发布功能(直接保存到本地)

```java
@Slf4j
@RestController
@RequestMapping("upload")
public class UploadController {

    @PostMapping("blog")
    public Result uploadImage(@RequestParam("file") MultipartFile image) {
        try {
            // 获取原始文件名称
            String originalFilename = image.getOriginalFilename();
            // 生成新文件名
            String fileName = createNewFileName(originalFilename);
            // 保存文件
            image.transferTo(new File(SystemConstants.IMAGE_UPLOAD_DIR, fileName));
            // 返回结果
            log.debug("文件上传成功，{}", fileName);
            return Result.ok(fileName);
        } catch (IOException e) {
            throw new RuntimeException("文件上传失败", e);
        }
    }

    @GetMapping("/blog/delete")
    public Result deleteBlogImg(@RequestParam("name") String filename) {
        File file = new File(SystemConstants.IMAGE_UPLOAD_DIR, filename);
        if (file.isDirectory()) {
            return Result.fail("错误的文件名称");
        }
        FileUtil.del(file);
        return Result.ok();
    }

    private String createNewFileName(String originalFilename) {
        // 获取后缀
        String suffix = StrUtil.subAfter(originalFilename, ".", true);
        // 生成目录
        String name = UUID.randomUUID().toString();
        int hash = name.hashCode();
        int d1 = hash & 0xF;
        int d2 = (hash >> 4) & 0xF;
        // 判断目录是否存在
        File dir = new File(SystemConstants.IMAGE_UPLOAD_DIR, StrUtil.format("/blogs/{}/{}", d1, d2));
        if (!dir.exists()) {
            dir.mkdirs();
        }
        // 生成文件名
        return StrUtil.format("/blogs/{}/{}/{}.{}", d1, d2, name, suffix);
    }
}
```





#### 商铺类型

```java
@RestController
@RequestMapping("/shop-type")
public class ShopTypeController {
    @Resource
    private IShopTypeService typeService;

    @GetMapping("list")
    public Result queryTypeList() {
        //增加缓存功能
        return typeService.getTypeList();

//        List<ShopType> typeList = typeService
//                .query().orderByAsc("sort").list();
    }
}
```

```java
public interface IShopTypeService extends IService<ShopType> {

    Result getTypeList();
}
```

```java
@Service
public class ShopTypeServiceImpl extends ServiceImpl<ShopTypeMapper, ShopType> implements IShopTypeService {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Override
    public Result getTypeList() {
        String key = RedisConstants.CACHE_SHOPTYPE_KEY;

        String cacheShopTypeJson = stringRedisTemplate.opsForValue().get(key);
        if (StrUtil.isNotBlank(cacheShopTypeJson)) {
            return Result.ok(JSONUtil.toList(cacheShopTypeJson,ShopType.class));
        }
        List<ShopType> shopTypes = query().orderByAsc("sort").list();
        if (shopTypes.isEmpty()){
            return Result.fail("Shop type not found");
        }
        stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shopTypes));
        return Result.ok(shopTypes);
    }
}
```

config类

```java
@Configuration
public class MvcConfig implements WebMvcConfigurer {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;
    /*
    这个类有@Configuration注解，是由Spring帮我们生成的，所以可以在这里注入生成template，再放到拦截器里
     */

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //刷新拦截器
        registry.addInterceptor(new RefreshTokenInterception(stringRedisTemplate));
        //登录拦截器
        registry.addInterceptor(new LoginInterception())
                .excludePathPatterns(   //这些功能是不拦截的
                        "/user/code",
                        "/user/login",
                        "/blog/hot",
                        "/shop/**",
                        "/shop-type/**",
                        "/voucher/**"
                );
    }
}
```

```java
@Configuration
public class MybatisConfig {
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));
        return interceptor;
    }
}
```

```java
@Configuration
public class RedissonConfig {

    @Bean
    public RedissonClient redissonClient(){
        //配置
        Config config = new Config();
        //单机
        config.useSingleServer().setAddress("redis://127.0.0.1:6379").setPassword("123456");
        // 创建RedissonClient对象
        return Redisson.create(config);
    }
}
```

```java
@Slf4j
@RestControllerAdvice
public class WebExceptionAdvice {

    @ExceptionHandler(RuntimeException.class)
    public Result handleRuntimeException(RuntimeException e) {
        log.error(e.toString(), e);
        return Result.fail("服务器异常");
    }
}
```

#### DTO

```java
@Data
public class LoginFormDTO {
    private String phone;
    private String code;
    private String password;
}
```

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Result {
    private Boolean success;
    private String errorMsg;
    private Object data;
    private Long total;

    public static Result ok(){
        return new Result(true, null, null, null);
    }
    public static Result ok(Object data){
        return new Result(true, null, data, null);
    }
    public static Result ok(List<?> data, Long total){
        return new Result(true, null, data, total);
    }
    public static Result fail(String errorMsg){
        return new Result(false, errorMsg, null, null);
    }
}
```

```java
/**
*@Description: 滚动分页返回对象
*@Param:
*@return:
*/
@Data
@AllArgsConstructor
@NoArgsConstructor
public class ScrollResult {
    private List<?> list;
    private Long minTime;
    private Integer offset;
}
```

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserDTO {
    private Long id;
    private String nickName;
    private String icon;
}
```

#### Utils

```java
/**
 * @ClassName: CacheClient
 * @Description: 封装的缓存工具类
 * @date: 2023/2/17  19:53
 * @Version: 1.0
 */

@Slf4j
@Component
public class CacheClient {

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    //线程池
    private static final ExecutorService CACHE_REBUILD_EXXECUTOR = Executors.newFixedThreadPool(10);

    public void set(String key, Object value, Long time, TimeUnit unit){
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value),time,unit);
    }

    public void setWithLogicExpire(String key, Object value, Long time, TimeUnit unit){
        RedisData redisData = new RedisData(LocalDateTime.now().plusSeconds(unit.toSeconds(time)),value);
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));
    }

    /**
    *@Description: 查询+解决缓存穿透 =》 泛型+函数式编程
    *@Param: [keyPrefix 前缀, id, type 泛型的类型, time 有效期, unit, dbFallback 函数式编程，根据id查询数据库的方法]
    *@return: R
    */
    public <R,ID> R queryWithPassThrough(String keyPrefix, ID id, Class<R> type, Long time, TimeUnit unit, Function<ID,R> dbFallback){
        String key = keyPrefix + id;
        // 1. 从redis中查询商铺缓存  （以json形式存储）
        String cacheJson = stringRedisTemplate.opsForValue().get(key);
        // 2. 判断是否存在
        if (StrUtil.isNotBlank(cacheJson)){
            // 3. 存在，直接返回
            return JSONUtil.toBean(cacheJson, type);
        }
        // 判断命中是否是空值
        if(cacheJson != null){
            //说明是缓存空值"" 返回错误 穿透结果
            return null;
        }
        // 4. 不存在，根据id查询数据库
        R r = dbFallback.apply(id);
        // 5. 不存在，返回错误
        if(r == null){
            // 将空值写入redis （避免缓存击穿问题）
            stringRedisTemplate.opsForValue().set(key,"", RedisConstants.CACHE_NULL_TTL, TimeUnit.MINUTES);
            // 返回错误信息
            return null;
        }
        // 6. 存在，写入redis
        set(key, r, time, unit);
        // 7. 返回数据
        return r;
    }

    /**
    *@Description: 查询+解决缓存击穿 => 逻辑过期
    *@Param: [keyPrefix, id, type, time, unit, dbFallback]
    *@return: R
    */
    public <R,ID> R queryWithLogicExpire(String keyPrefix, ID id, Class<R> type, Long time, TimeUnit unit, Function<ID,R> dbFallback) {
        String key = keyPrefix + id;
        // 1. 从redis中查询
        String cacheJson = stringRedisTemplate.opsForValue().get(key);
        // 2. 判断是否存在
        if (StrUtil.isBlank(cacheJson)) {
            //未命中 返回空
            return null;
        }
        // 3. 存在，反序列化为对象
        RedisData redisData = JSONUtil.toBean(cacheJson, RedisData.class);
        R r = JSONUtil.toBean((JSONObject) redisData.getData(), type);
        LocalDateTime expireTime = redisData.getExpireTime();
        // 4. 判断是否过期
        if(!expireTime.isAfter(LocalDateTime.now())){
            // 5.1 未过期 返回
            return r;
        }
        // 5.2 过期，需要缓存重建
        // 6. 缓存重建
        // 6.1 获取互斥锁
        String lockKey = RedisConstants.LOCK_SHOP_KEY+id;
        boolean isLock = tryLock(lockKey);
        // 6.2 判断是否获取锁成功
        // 6.3 成功 开启线程执行重建过程
        if(isLock){
            //可以在次再次检测redis缓存是否过期，doublecheck 匿名内部类
            CACHE_REBUILD_EXXECUTOR.submit(new Runnable() {
                @Override
                public void run() {
                    // 查询数据库
                    R curR = dbFallback.apply(id);
                    //写入redis
                    CacheClient.this.setWithLogicExpire(key, curR, time, unit);
                    //释放锁
                    CacheClient.this.unLock(lockKey);
                }
            });
        }
        // 6.4 返回过期商品信息
        return r;
    }

    private boolean tryLock(String key){
        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", RedisConstants.LOCK_SHOP_TTL, TimeUnit.SECONDS);
        return BooleanUtil.isTrue(flag);   //转成基本类型返回，如果直接返回，拆箱的时候可能会造成空指针
    }

    private void unLock(String key){
        stringRedisTemplate.delete(key);
    }

}
```

```java
/**
 * @ClassName: ILock
 * @Description: 分布式锁  接口
 * @author: oumuanode
 * @date: 2023/2/21  22:00
 * @Version: 1.0
 */
public interface ILock {

    /**
    *@Description: 尝试获取锁
    *@Param: timeoutSec 锁持有的超时时间，过期后自动释放
    *@return: boolean true代表获取锁成功；false代表获取锁失败
    */
    public boolean tryLock(long timeoutSec);

    /**
    *@Description: 
    *@Param: []
    *@return: void
    */
    public void unlock();

}
```

```java
/**
 * @ClassName: LoginInterception
 * @Description: 登录校验拦截器
 * @author: oumuanode
 * @date: 2023/3/7  22:17
 * @Version: 1.0
 */
@Slf4j
public class LoginInterception implements HandlerInterceptor {

    @Override
    /*
    这个是请求预处理的方法，只有当这个方法返回值为 true 的时候，后面的方法才会执行
    SpringMVC 中的拦截器，相当于 Jsp/Servlet 中的过滤器，只不过拦截器的功能更为强大。
    */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1. 判断是否需要拦截：ThreadLocal中是否有用户
        if (UserHolder.getUser() == null){
            response.setStatus(401);
            return false;  //拦截
        }
        //有用户，则放行
        return true;
    }

}
```

```java
/**
 * @ClassName: ObjectToMap
 * @Description: 写入redis前 序列化 为Value为String类型的Map
 */
public class ObjectToMap {

    public static Map<String,String> UserDto2Map(UserDTO userDTO){
        Map<String,String> map = new HashMap<>();
        map.put("id",userDTO.getId().toString());
        map.put("nickName",userDTO.getNickName());
        map.put("icon",userDTO.getIcon());
        return map;
    }
}
```

```java
public class PasswordEncoder {

    public static String encode(String password) {
        // 生成盐
        String salt = RandomUtil.randomString(20);
        // 加密
        return encode(password,salt);
    }
    private static String encode(String password, String salt) {
        // 加密
        return salt + "@" + DigestUtils.md5DigestAsHex((password + salt).getBytes(StandardCharsets.UTF_8));
    }
    public static Boolean matches(String encodedPassword, String rawPassword) {
        if (encodedPassword == null || rawPassword == null) {
            return false;
        }
        if(!encodedPassword.contains("@")){
            throw new RuntimeException("密码格式不正确！");
        }
        String[] arr = encodedPassword.split("@");
        // 获取盐
        String salt = arr[0];
        // 比较
        return encodedPassword.equals(encode(rawPassword, salt));
    }
}
```

```java
/***
*@Description: redis所需要用的一些常量
*@Param: 
*@return: 
*/
public class RedisConstants {
    public static final String LOGIN_CODE_KEY = "login:code:";
    public static final Long LOGIN_CODE_TTL = 60L;
    public static final String LOGIN_USER_KEY = "login:token:";
    public static final Long LOGIN_USER_TTL = 30L;

    public static final String CACHE_SHOPTYPE_KEY = "cache:shoptype";

    public static final Long CACHE_NULL_TTL = 2L;

    public static final Long CACHE_SHOP_TTL = 30L;
    public static final String CACHE_SHOP_KEY = "cache:shop:";

    public static final String LOCK_SHOP_KEY = "lock:shop:";
    public static final Long LOCK_SHOP_TTL = 10L;

    public static final String SECKILL_STOCK_KEY = "seckill:stock:";
    public static final String BLOG_LIKED_KEY = "blog:liked:";
    public static final String FEED_KEY = "feed:";
    public static final String SHOP_GEO_KEY = "shop:geo:";
    public static final String USER_SIGN_KEY = "sign:";
}
```

```java
/**
*@Description: 逻辑过期 实体类
*/
@Data
@NoArgsConstructor
@AllArgsConstructor
public class RedisData {
    //逻辑过期时间
    private LocalDateTime expireTime;
    private Object data;
}
```

```java
/**
 * @ClassName: RedisIdWorker
 * @Description: 全局ID生成器 利用redis生成全局唯一ID
 * @Version: 1.0
 */
@Component
public class RedisIdWorker {

    /**
    *@Description: 开始的时间戳
    */
    private static final long BEGIN_TIMESTAMP = 1640995200L;

    /**
    *@Description: 序列号位数
    */
    private static final int COUNT_BITS = 32;

    @Autowired
    private StringRedisTemplate stringRedisTemplate;


    /**
    *@Description:
     * 64 位的long
     * 1位符号位   31位时间戳（单位为s，可以用69年）   32位序列号
    *@Param: [keyPrefix 业务的前缀]
    *@return: long
    */
    public long nexId(String keyPrefix){
        // 1. 生成时间戳
        LocalDateTime now = LocalDateTime.now();
        long timestamp = now.toEpochSecond(ZoneOffset.UTC) - BEGIN_TIMESTAMP;

        // 2. 生成序列号(利用redis自增长)
        // 2.1 获取当前日期，精确到天(一天一个key)
        //   避免超过32位上限（一天一个自增） + 方便统计
        String date = now.format(DateTimeFormatter.ofPattern("yyyy:MM:dd"));
        // 2.2 自增长
        long count = stringRedisTemplate.opsForValue().increment("icr:" + keyPrefix + ":" + date);

        // 3. 拼接并返回
        return timestamp << COUNT_BITS | count;  //+也可以，但位运算比加减快多了
    }

    public static void main(String[] args) {
        LocalDateTime time = LocalDateTime.of(2022, 1, 1, 0, 0, 0);
        long second = time.toEpochSecond(ZoneOffset.UTC);  //转化为秒
        System.out.println(second);
    }
}
```

```java
/**
 * @ClassName: ReFreshTokenInterception
 * @Description: 拦截所有操作，目的是为token刷新存活时间； 至于验证是否登录由下一个拦截器进行判断
 * @date: 2023/2/14  22:07
 * @Version: 1.0
 */
public class RefreshTokenInterception implements HandlerInterceptor {

    private StringRedisTemplate stringRedisTemplate;

    public RefreshTokenInterception(StringRedisTemplate stringRedisTemplate){
        this.stringRedisTemplate = stringRedisTemplate;
    }

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 1. 获取请求头中的token
        String token = request.getHeader("authorization");

        if(StrUtil.isBlank(token)){
            return true;
        }
        // 2. 基于token获取redis中的用户
        Map<Object, Object> userMap = stringRedisTemplate.opsForHash().entries(RedisConstants.LOGIN_USER_KEY + token);
        // 3. 判断用户是否存在
        if(userMap.isEmpty()) {
            // 4. 不存在
            return true;
        }
        // 5. 将查询到的Hash数据转为UserDto对象
        UserDTO userDTO = BeanUtil.fillBeanWithMap(userMap, new UserDTO(), false);
        // 6. 存在，用户信息保存到ThreadLocal
        UserHolder.saveUser(userDTO);
        // 7. 刷新token有效期
        stringRedisTemplate.expire(RedisConstants.LOGIN_USER_KEY+token,RedisConstants.LOGIN_USER_TTL, TimeUnit.MINUTES);
        return true;
    }

    @Override
    /**
     * 调用前提：preHandle返回true
     * DispatcherServlet进行视图的渲染之后
     * 多用于清理资源
     */
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        //移除用户
        UserHolder.removeUser();
    }
}
```

```java
/**
 * @author
 * 正则表达式
 */
public abstract class RegexPatterns {
    /**
     * 手机号正则
     */
    public static final String PHONE_REGEX = "^1([38][0-9]|4[579]|5[0-3,5-9]|6[6]|7[0135678]|9[89])\\d{8}$";
    /**
     * 邮箱正则
     */
    public static final String EMAIL_REGEX = "^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$";
    /**
     * 密码正则。4~32位的字母、数字、下划线
     */
    public static final String PASSWORD_REGEX = "^\\w{4,32}$";
    /**
     * 验证码正则, 6位数字或字母
     */
    public static final String VERIFY_CODE_REGEX = "^[a-zA-Z\\d]{6}$";

}
```

```java
/**
 * @author
 * 校验正则的实现类
 */
public class RegexUtils {
    /**
     * 是否是无效手机格式  反向的校验
     * @param phone 要校验的手机号
     * @return true:符合，false：不符合
     */
    public static boolean isPhoneInvalid(String phone){
        return mismatch(phone, RegexPatterns.PHONE_REGEX);
    }
    /**
     * 是否是无效邮箱格式
     * @param email 要校验的邮箱
     * @return true:符合，false：不符合
     */
    public static boolean isEmailInvalid(String email){
        return mismatch(email, RegexPatterns.EMAIL_REGEX);
    }

    /**
     * 是否是无效验证码格式
     * @param code 要校验的验证码
     * @return true:符合，false：不符合
     */
    public static boolean isCodeInvalid(String code){
        return mismatch(code, RegexPatterns.VERIFY_CODE_REGEX);
    }

    // 校验是否不符合正则格式
    private static boolean mismatch(String str, String regex){
        if (StrUtil.isBlank(str)) {
            return true;
        }
        return !str.matches(regex);
    }
}
```

```java
/**
 * @ClassName: SimpleRedisLock
 * @Description: 实现Redis分布式锁
 * @Version: 1.0
 */


public class SimpleRedisLock implements ILock{

    private StringRedisTemplate stringRedisTemplate;
    private String name;  //业务的名称（也就是锁的名称）

    public SimpleRedisLock(String name, StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
        this.name = name;
    }

    private static final String KEY_PREFIX = "lock:";

    /**
     * UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的
     * UUID由以下几部分的组合：
     * （1）当前日期和时间，UUID的第一个部分与时间有关，如果你在生成一个UUID之后，过几秒又生成一个UUID，则第一个部分不同，其余相同。
     * （2）时钟序列。
     * （3）全局唯一的IEEE机器识别号，如果有网卡，从网卡MAC地址获得，没有网卡以其他方式获得。
     * 通过组成可以看出，首先每台机器的mac地址是不一样的，那么如果出现重复，可能是同一时间下生成的id可能相同，不会存在不同时间内生成重复的数据
    */
    private static final String ID_PREFIX = UUID.randomUUID().toString(true)+"-";   //线程标识前缀(区分集群下不同主机(不同JVM) 而ThreadID在jvm内部是自增生成的)

    private static final DefaultRedisScript<Long> UNLOCK_SCRIPT;
    static {
        UNLOCK_SCRIPT = new DefaultRedisScript<>();
        UNLOCK_SCRIPT.setLocation(new ClassPathResource("./lua/unlock.lua"));
        UNLOCK_SCRIPT.setResultType(Long.class);
    }

    @Override
    public boolean tryLock(long timeoutSec) {
        //获取线程标识  (UUID:区分不同JVM + 线程id：区分同一个JVM中的不同线程)
        String threadId = ID_PREFIX + Thread.currentThread().getId();  //解决redis分布式锁误删问题
        //获取锁
        Boolean success = stringRedisTemplate.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);
        //注意自动拆箱时success为空指针的可能性
        return Boolean.TRUE.equals(success);   //也是hutool的 BooleanUtil.isTrue() 的实现方法
    }

    /**
    *@Description:  Redis+Lua脚本 改善分布式锁原子性问题
    */
    @Override
    public void unlock() {
        //调用lua脚本
        stringRedisTemplate.execute(
                UNLOCK_SCRIPT,
                Collections.singletonList(KEY_PREFIX + name),
                ID_PREFIX + Thread.currentThread().getId()
                );
    }

    /**
    *@Description: 解决redis误删的旧方法 （ 无法保证原子性，存在线程安全问题 ）
    */
//    @Override
//    public void unlock() {
//        //获取线程标识
//        String threadId = ID_PREFIX + Thread.currentThread().getId();
//
//        //*********************** 由于此处是分开执行的，所以可能会导致判断一致后，在删除前出现阻塞，锁失效，新线程拿锁，旧线程继续执行删掉了新线程的锁（并发问题） ***********************************************************
//        /**  所以关键问题是确保 拿、验证、删除 的原子性操作  => redis+Lua脚本
//        */
//        //获取锁中标识并判断标识是否一致
////        String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);
////        if(threadId.equals(id)){
////            stringRedisTemplate.delete(KEY_PREFIX + name);
////        }
//        //**********************************************************************************
//    }
}
```

```java
/***
*@Description: 系统所用的一些常量
*@Param: 
*@return: 
*/
public class SystemConstants {
    public static final String IMAGE_UPLOAD_DIR = "D:\\RedisLearn\\nginx-1.18.0\\nginx-1.18.0\\html\\hmdp\\imgs\\";
    public static final String USER_NICK_NAME_PREFIX = "user_";   //新用户的名称前缀
    public static final int DEFAULT_PAGE_SIZE = 5;
    public static final int MAX_PAGE_SIZE = 10;
}
```

比较重要:

```java
public class UserHolder {
    private static final ThreadLocal<UserDTO> tl = new ThreadLocal<>();

    public static void saveUser(UserDTO user){
        tl.set(user);
    }

    public static UserDTO getUser(){
        return tl.get();
    }

    public static void removeUser(){
        tl.remove();
    }
}
```

#### yaml

```yaml
server:
  port: 8081
spring:
  application:
    name: hmdp
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/hmdp?useUnicode=true&serverTimezone=Asia/Shanghai&characterEncoding=utf8&autoReconnect=true&allowMultiQueries=true
    username: root
    password: 123456
  redis:
    host: 127.0.0.1
    port: 6379
    password: 123456
    lettuce:
      pool:
        max-active: 10
        max-idle: 10
        min-idle: 1
        time-between-eviction-runs: 10s
  jackson:
    default-property-inclusion: non_null # JSON处理时忽略非空字段
mybatis-plus:
  type-aliases-package: com.hmdp.entity # 别名扫描包,目的是为了省略resultType里的代码量
logging:
  level:
    com.hmdp: debug
```
